import{_ as e}from"./plugin-vue_export-helper-c27b6911.js";import{o,c as s,a}from"./app-fd217ae5.js";const c={},n=a(`<h2 id="v-on事件修饰符和键盘修饰符的作用" tabindex="-1"><a class="header-anchor" href="#v-on事件修饰符和键盘修饰符的作用" aria-hidden="true">#</a> <code>v-on</code>事件修饰符和键盘修饰符的作用</h2><p>事件修饰符：主要是用于处理浏览器上的默认行为，比如阻止事件的冒泡、阻止 a 标签、form 表单的默认时间</p><ul><li>阻止默认行为<code>.prevent</code></li><li>只触发一次事件<code>.once</code></li><li>保证事件由自己触发，不会经过冒泡或者捕获进行触发<code>.self</code></li><li>阻止冒泡<code>.stop</code></li></ul><p>键盘修饰符主要针对<code>keyup</code>/<code>keydown</code>，</p><p>自定义键盘修饰符</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="shiki one-dark-pro" style="background-color:#282c34;" tabindex="0"><code><span class="line"><span style="color:#E5C07B;">Vue</span><span style="color:#ABB2BF;">.</span><span style="color:#E5C07B;">config</span><span style="color:#ABB2BF;">.</span><span style="color:#E06C75;">f1</span><span style="color:#ABB2BF;"> </span><span style="color:#56B6C2;">=</span><span style="color:#ABB2BF;"> </span><span style="color:#E06C75;">键码</span></span>
<span class="line"><span style="color:#ABB2BF;">@</span><span style="color:#E5C07B;">keyup</span><span style="color:#ABB2BF;">.</span><span style="color:#E06C75;">f1</span><span style="color:#ABB2BF;"> </span><span style="color:#56B6C2;">=</span><span style="color:#ABB2BF;"> </span><span style="color:#98C379;">&#39;fff&#39;</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="v-if和v-show区别-使用场景" tabindex="-1"><a class="header-anchor" href="#v-if和v-show区别-使用场景" aria-hidden="true">#</a> <code>v-if</code>和<code>v-show</code>区别,使用场景</h2><p>都来用来控制元素显示和隐藏，当值是<code>true</code>元素显示，值为<code>false</code>元素隐藏</p><ul><li>v-if 当值为<code>true</code>时会创建元素，为<code>false</code>时会删除元素</li><li>v-show 当值为<code>true</code>时会<code>display:block</code>;为<code>false</code>时会<code>display:none</code></li></ul><p>使用场景：当元素显示隐藏切换频繁时使用<code>v-show</code>，反之使用<code>v-if</code>;例如页面加载数据时的<code>loading</code>动画可以使用<code>v-if</code>;页面中某个元素需要使用动画效果，这个动画效果需要人为进行操作控制，那么最好使用<code>v-show</code>，加入购物车时飞入动画</p><h2 id="v-cloak解决差值表达式闪烁的原理" tabindex="-1"><a class="header-anchor" href="#v-cloak解决差值表达式闪烁的原理" aria-hidden="true">#</a> <code>v-cloak</code>解决差值表达式闪烁的原理</h2><p>由于网速的原因导致<code>vue.js</code>没有被加载回来，此时页面中的差值表达式不会被<code>Vue</code>实例解析，浏览器进行解析的时候会直接当做字符串；然后<code>vue.js</code>加载回来之后，<code>Vue</code>实例又能进行解析，那么插值表达式就会被解析成具体的值，这个过程会出现闪烁现象<br><code>v-cloak</code>原理：使用<code>v-clock</code>指令绑定到元素上面之后，再配合<code>[v-cloak]｛display:none｝</code>这个样式进行控制；在浏览器进行解析时，浏览器会将属性选择器的样式作用于元素身上，该元素会被隐藏；然后<code>vue</code>进行解析时，会将<code>v-cloak</code>从元素身上删除，样式也随之失效，插值表达式中的值也能够显示出来</p><h2 id="什么是vue双向数据绑定-原理" tabindex="-1"><a class="header-anchor" href="#什么是vue双向数据绑定-原理" aria-hidden="true">#</a> 什么是<code>Vue</code>双向数据绑定，原理？</h2><p>数据劫持，<code>ES5</code>中的<code>Object.defineProperty()</code></p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="shiki one-dark-pro" style="background-color:#282c34;" tabindex="0"><code><span class="line"><span style="color:#C678DD;">var</span><span style="color:#ABB2BF;"> </span><span style="color:#E06C75;">value</span><span style="color:#ABB2BF;"> </span><span style="color:#56B6C2;">=</span><span style="color:#ABB2BF;"> </span><span style="color:#98C379;">&#39;zs&#39;</span></span>
<span class="line"><span style="color:#E5C07B;">Object</span><span style="color:#ABB2BF;">.</span><span style="color:#61AFEF;">defineProperty</span><span style="color:#ABB2BF;">(</span><span style="color:#E06C75;">obj</span><span style="color:#ABB2BF;">, </span><span style="color:#98C379;">&#39;name&#39;</span><span style="color:#ABB2BF;">, {</span></span>
<span class="line"><span style="color:#ABB2BF;">  </span><span style="color:#61AFEF;">get</span><span style="color:#ABB2BF;">() {</span></span>
<span class="line"><span style="color:#ABB2BF;">    </span><span style="color:#C678DD;">return</span><span style="color:#ABB2BF;"> </span><span style="color:#E06C75;">value</span></span>
<span class="line"><span style="color:#ABB2BF;">  },</span></span>
<span class="line"><span style="color:#ABB2BF;">  </span><span style="color:#61AFEF;">set</span><span style="color:#ABB2BF;">(</span><span style="color:#E06C75;font-style:italic;">v</span><span style="color:#ABB2BF;">) {</span></span>
<span class="line"><span style="color:#ABB2BF;">    </span><span style="color:#7F848E;font-style:italic;">// 设置值的时候就是数据劫持，只要走这个方法表示模型中的数据发生了变化</span></span>
<span class="line"><span style="color:#ABB2BF;">    </span><span style="color:#E06C75;">value</span><span style="color:#ABB2BF;"> </span><span style="color:#56B6C2;">=</span><span style="color:#ABB2BF;"> </span><span style="color:#E06C75;">v</span></span>
<span class="line"><span style="color:#ABB2BF;">  },</span></span>
<span class="line"><span style="color:#ABB2BF;">})</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>当模型中数据发生变化时会触发<code>Object.defineProperty</code>的<code>set</code>方法，在这个方法内部能够劫持到数据的改变，然后就可以在该方法内部通知视图更新； 视图中的数据如何同步到模型中，监听表单元素的<code>change</code>事件，在<code>change</code>事件中可以拿到用户输入的数据，然后给模型中的数据赋值</p><p>---angular 双向数据绑定<br> 脏数据监测：会使用定时器进行轮询，并不是将定时器一直开着，只有触发了指定的一些方法时才会进行轮询，$apply 发送异步请求，触发了定时器也会轮询</p><h2 id="vue2如何监测数组变化" tabindex="-1"><a class="header-anchor" href="#vue2如何监测数组变化" aria-hidden="true">#</a> <code>vue2</code>如何监测数组变化</h2><p>使用了函数劫持的方式，重写了数组的方法，<code>Vue</code>将<code>data</code>中的数组进行了原型链重写，指向了自己定义的数组原型方法。这样当调用数组<code>api</code>时，可以通知依赖更新。如果数组中包含着引用类型，会对数组中的引用类型再次递归遍历进行监控。这样就实现了监测数组变化</p><h2 id="scoped作用原理-怎么解决加了scoped后动态渲染的html标签样式不能修改的问题" tabindex="-1"><a class="header-anchor" href="#scoped作用原理-怎么解决加了scoped后动态渲染的html标签样式不能修改的问题" aria-hidden="true">#</a> <code>scoped</code>作用原理，怎么解决加了<code>scoped</code>后动态渲染的<code>HTML</code>标签样式不能修改的问题</h2><p><code>scoped</code>可以隔离组件之间的样式，避免样式污染 作用原理：当一个组件的<code>style</code>加了<code>scoped</code>后，首先<code>vue</code>解析当前组件时会给当前组件中所有元素加上一个随机属性，然后<code>style</code>中书写的样式会变成属性选择器，那么即使其他组件有相同的样式或者相同的标签，由于随机添加的属性是不一样的，组件之间的样式也不会相互影响<br> 当在父组件中去修改子组件中标签样式，可以使用深度作用选择器，在<code>css</code>中使用 <code>.aaa &gt;&gt;&gt; .bbb</code>，在<code>scss</code>中使用 <code>.aaa /deep/ .bbb</code></p><h2 id="vue生命周期" tabindex="-1"><a class="header-anchor" href="#vue生命周期" aria-hidden="true">#</a> <code>Vue</code>生命周期</h2><p>生命周期就是在<code>vue</code>实例执行过程中会触发的一批函数，这些函数可以帮助我们处理不同时间段的业务逻辑。</p><table><thead><tr><th style="text-align:left;"> </th><th style="text-align:left;"> </th></tr></thead><tbody><tr><td style="text-align:left;">beforeCreate created</td><td style="text-align:left;">实例创建阶段</td></tr><tr><td style="text-align:left;">beforeMount mounted</td><td style="text-align:left;">DOM 渲染阶段</td></tr><tr><td style="text-align:left;">beforeUpdate updated</td><td style="text-align:left;">数据更新阶段</td></tr><tr><td style="text-align:left;">beforeDistory distorted</td><td style="text-align:left;">实例销毁阶段</td></tr></tbody></table><h2 id="vue-router路由模式有几种-原理分别是什么" tabindex="-1"><a class="header-anchor" href="#vue-router路由模式有几种-原理分别是什么" aria-hidden="true">#</a> <code>vue-router</code>路由模式有几种，原理分别是什么</h2><p><code>vue-router</code>路由库是用哪种技术实现的，总共有两种，分别叫<code>hash模式</code>和<code>history模式</code>，默认<code>model:&#39;hash&#39;</code>,</p><ul><li><code>hash</code>模式：地址上带有<code>#</code>号；<code>URL</code>地址可以放在任意标签中打开；可以兼容低版本浏览器</li><li><code>history</code>模式：地址上没有#号，更加符合<code>URL</code>形式；<code>URL</code>地址不能重复打开； <code>hash</code>模式原理：监听<code>hashchange</code>事件，可以调用<code>window.location.hash</code>获取到锚点值，和路由规则进行匹配，匹配到之后将路由规则中定义的组件渲染到页面 <code>history</code>模式原理：利用<code>HTML5</code>新提供的<code>history.pushState API</code>来完成<code>URL</code>跳转而无需重新加载页面 <code>history</code>模式需要后台进行相关配置：要在服务器增加一个覆盖所有情况的候选资源：如果<code>URL</code>匹配不到任何静态资源则应该返回同一个<code>index.html</code>页面，这个页面就是你<code>app</code>依赖的页面</li></ul><h2 id="vue-router导航钩子函数使用场景" tabindex="-1"><a class="header-anchor" href="#vue-router导航钩子函数使用场景" aria-hidden="true">#</a> <code>vue-router</code>导航钩子函数使用场景</h2><ul><li><code>beforeEach</code>全局守卫，在路由跳转时会对路由进行拦截，只有调用了<code>next</code>函数才会释放路由，使用场景：通常在后台管理系统中，页面是需要登录之后才能访问，那么对于所有的页面跳转都需要使用 <code>beforeEach</code>进行拦截判断是否登录</li><li><code>beforeEnter</code>路由独享守卫，只会拦截加了独享守卫的路由跳转。使用场景：如果整个项目中只有某一部分页面是需要登录之后才能访问，此时只能针对这一部分页面的路由规则加上独享守卫进行拦截</li></ul><h2 id="vue-router路由懒加载-单页应用程序优的性能优化" tabindex="-1"><a class="header-anchor" href="#vue-router路由懒加载-单页应用程序优的性能优化" aria-hidden="true">#</a> <code>vue-router</code>路由懒加载（单页应用程序优的性能优化）</h2><p>路由懒加载：使用懒加载可以在跳转到具体路由时才去加载对应的组件代码，没有访问的路由的组件代码永远不会加载回来<br> 用法将导入组件的方式换成 <code>const Foo = ()=&gt; import(&#39;./Foo.vue&#39;)</code></p><h2 id="vue-use-方法作用-vue插件实现" tabindex="-1"><a class="header-anchor" href="#vue-use-方法作用-vue插件实现" aria-hidden="true">#</a> <code>Vue.use()</code>方法作用？<code>Vue</code>插件实现</h2><p><code>Vue.use</code>是用来安装<code>Vue</code>的插件 插件可以实现的功能：添加全局方法或属性，添加全局资源（指令、过滤器、组件），注入组件 如何实现插件：插件必须实现一个<code>install</code>方法，这个方法接收一个参数是<code>Vue</code>，这个方法内部就可以去添加全局的组件以及实例的属性。然后在使用插件时，调用<code>Vue.use(插件对象)</code>，则<code>install</code>方法中的形参<code>Vue</code>就会接收到实参<code>Vue</code></p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="shiki one-dark-pro" style="background-color:#282c34;" tabindex="0"><code><span class="line"><span style="color:#E5C07B;">MyPlugin</span><span style="color:#ABB2BF;">.</span><span style="color:#61AFEF;">install</span><span style="color:#ABB2BF;"> </span><span style="color:#56B6C2;">=</span><span style="color:#ABB2BF;"> </span><span style="color:#C678DD;">function</span><span style="color:#ABB2BF;"> (</span><span style="color:#E06C75;font-style:italic;">Vue</span><span style="color:#ABB2BF;">, </span><span style="color:#E06C75;font-style:italic;">options</span><span style="color:#ABB2BF;">) {}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h2 id="axios拦截函数的使用场景" tabindex="-1"><a class="header-anchor" href="#axios拦截函数的使用场景" aria-hidden="true">#</a> <code>axios</code>拦截函数的使用场景</h2><ul><li>请求拦截:在发送请求之前，对请求对象做相关配置，给请求头添加验证属性（登录校验）、设置参数数据格式（<code>content-Type</code>），</li></ul><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="shiki one-dark-pro" style="background-color:#282c34;" tabindex="0"><code><span class="line"><span style="color:#E5C07B;">axios</span><span style="color:#ABB2BF;">.</span><span style="color:#E5C07B;">interceptors</span><span style="color:#ABB2BF;">.</span><span style="color:#E5C07B;">request</span><span style="color:#ABB2BF;">.</span><span style="color:#61AFEF;">use</span><span style="color:#ABB2BF;">(</span><span style="color:#C678DD;">function</span><span style="color:#ABB2BF;"> (</span><span style="color:#E06C75;font-style:italic;">config</span><span style="color:#ABB2BF;">) {</span></span>
<span class="line"><span style="color:#ABB2BF;">  </span><span style="color:#C678DD;">return</span><span style="color:#ABB2BF;"> </span><span style="color:#E06C75;">config</span></span>
<span class="line"><span style="color:#ABB2BF;">})</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>响应拦截:当接口返回的信息是统一的类型时，如果都在具体的请求函数里面去做处理，比较繁琐，可以在响应拦截器中先做统一处理，再分发到具体的函数中。当后台的 token 过期时，如果在每一个请求函数中都做判断，然后跳转页面比较麻烦，由于 token 过期后台会返回规定的状态码，那么就可以使用响应拦截在拦截器中进行跳转</li></ul><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="shiki one-dark-pro" style="background-color:#282c34;" tabindex="0"><code><span class="line"><span style="color:#E5C07B;">axios</span><span style="color:#ABB2BF;">.</span><span style="color:#E5C07B;">interceptors</span><span style="color:#ABB2BF;">.</span><span style="color:#E5C07B;">response</span><span style="color:#ABB2BF;">.</span><span style="color:#61AFEF;">use</span><span style="color:#ABB2BF;">(</span><span style="color:#C678DD;">function</span><span style="color:#ABB2BF;"> (</span><span style="color:#E06C75;font-style:italic;">response</span><span style="color:#ABB2BF;">) {</span></span>
<span class="line"><span style="color:#ABB2BF;">  </span><span style="color:#C678DD;">return</span><span style="color:#ABB2BF;"> </span><span style="color:#E06C75;">response</span></span>
<span class="line"><span style="color:#ABB2BF;">})</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="代理-解决的是开发阶段跨域问题" tabindex="-1"><a class="header-anchor" href="#代理-解决的是开发阶段跨域问题" aria-hidden="true">#</a> 代理（解决的是开发阶段跨域问题）</h2><p>代理是通过服务器向服务器发送数据请求不存在跨域问题的机制解决浏览器向存在跨域问题的服务器发请求的技术 <code>C</code> -&gt; <code>S</code> 在客户端所在电脑上搭建一个服务器<code>P</code>， <code>C</code> -&gt; <code>P</code> -&gt; <code>S</code> 跨域通常存在于开发阶段</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="shiki one-dark-pro" style="background-color:#282c34;" tabindex="0"><code><span class="line"><span style="color:#7F848E;font-style:italic;">// webpack.config.js配置文件导出对象中加入</span></span>
<span class="line"><span style="color:#E06C75;">devServer</span><span style="color:#ABB2BF;">: {</span></span>
<span class="line"><span style="color:#ABB2BF;">   </span><span style="color:#7F848E;font-style:italic;">// 代理跨域</span></span>
<span class="line"><span style="color:#ABB2BF;">   </span><span style="color:#E06C75;">proxy</span><span style="color:#ABB2BF;">: {</span></span>
<span class="line"><span style="color:#ABB2BF;">    </span><span style="color:#98C379;">&#39;/api&#39;</span><span style="color:#ABB2BF;">: {</span></span>
<span class="line"><span style="color:#ABB2BF;">       </span><span style="color:#E06C75;">target</span><span style="color:#ABB2BF;">: </span><span style="color:#98C379;">&#39;http://vue.xxx.io/api&#39;</span><span style="color:#ABB2BF;">, </span><span style="color:#7F848E;font-style:italic;">//需要被代理的api根域名</span></span>
<span class="line"><span style="color:#ABB2BF;">       </span><span style="color:#E06C75;">changeOrigin</span><span style="color:#ABB2BF;">: </span><span style="color:#D19A66;">true</span><span style="color:#ABB2BF;">, </span><span style="color:#7F848E;font-style:italic;">// 是否跨域</span></span>
<span class="line"><span style="color:#ABB2BF;">       </span><span style="color:#E06C75;">pathRewrite</span><span style="color:#ABB2BF;">: {</span></span>
<span class="line"><span style="color:#ABB2BF;">           </span><span style="color:#98C379;">&#39;^/api&#39;</span><span style="color:#ABB2BF;">: </span><span style="color:#98C379;">&#39;&#39;</span><span style="color:#ABB2BF;"> </span><span style="color:#7F848E;font-style:italic;">// 重写(target中只有根域名时不需要配置此选项)</span></span>
<span class="line"><span style="color:#ABB2BF;">       }</span></span>
<span class="line"><span style="color:#ABB2BF;">     }</span></span>
<span class="line"><span style="color:#ABB2BF;">   }</span></span>
<span class="line"><span style="color:#ABB2BF;">}</span></span>
<span class="line"><span style="color:#56B6C2;">---------------------------</span></span>
<span class="line"><span style="color:#7F848E;font-style:italic;">// vue-cli中</span></span>
<span class="line"><span style="color:#7F848E;font-style:italic;">// config/index.js中dev</span></span>
<span class="line"><span style="color:#E06C75;">proxyTable</span><span style="color:#ABB2BF;">: {</span></span>
<span class="line"><span style="color:#ABB2BF;">   </span><span style="color:#98C379;">&#39;/api&#39;</span><span style="color:#ABB2BF;">: {</span></span>
<span class="line"><span style="color:#ABB2BF;">        </span><span style="color:#E06C75;">target</span><span style="color:#ABB2BF;">: </span><span style="color:#98C379;">&#39;http://vue.xxx.io/api&#39;</span><span style="color:#ABB2BF;">,</span></span>
<span class="line"><span style="color:#ABB2BF;">        </span><span style="color:#E06C75;">changeOrigin</span><span style="color:#ABB2BF;">: </span><span style="color:#D19A66;">true</span><span style="color:#ABB2BF;">,</span></span>
<span class="line"><span style="color:#ABB2BF;">        </span><span style="color:#E06C75;">pathRewrite</span><span style="color:#ABB2BF;">: {</span></span>
<span class="line"><span style="color:#ABB2BF;">             </span><span style="color:#98C379;">&#39;^/api&#39;</span><span style="color:#ABB2BF;">: </span><span style="color:#98C379;">&#39;&#39;</span></span>
<span class="line"><span style="color:#ABB2BF;">        }</span></span>
<span class="line"><span style="color:#ABB2BF;">   }</span></span>
<span class="line"><span style="color:#ABB2BF;">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>cors</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="shiki one-dark-pro" style="background-color:#282c34;" tabindex="0"><code><span class="line"><span style="color:#E5C07B;">res</span><span style="color:#ABB2BF;">.</span><span style="color:#61AFEF;">header</span><span style="color:#ABB2BF;">(</span><span style="color:#98C379;">&quot;Access-Control-Allow-Origin&quot;</span><span style="color:#ABB2BF;">,</span><span style="color:#98C379;">&quot;*&quot;</span><span style="color:#ABB2BF;">)</span><span style="color:#E06C75;">允许所有域请求</span></span>
<span class="line"><span style="color:#E5C07B;">res</span><span style="color:#ABB2BF;">.</span><span style="color:#61AFEF;">header</span><span style="color:#ABB2BF;">(</span><span style="color:#98C379;">&quot;Access-Control-Allow-Headers&quot;</span><span style="color:#ABB2BF;">,</span><span style="color:#98C379;">&quot;X-Request-With&quot;</span><span style="color:#ABB2BF;">);</span></span>
<span class="line"><span style="color:#E5C07B;">res</span><span style="color:#ABB2BF;">.</span><span style="color:#61AFEF;">header</span><span style="color:#ABB2BF;">(</span><span style="color:#98C379;">&quot;Access-Control-Allow-Methods&quot;</span><span style="color:#ABB2BF;">,</span><span style="color:#98C379;">&quot;*&quot;</span><span style="color:#ABB2BF;">);</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>JSONP<br> 在<code>script</code>发送请求前定义一个函数，在 script 发送请求<code>&lt;script src = &#39;http:..?cb=getdata&#39;&gt;</code>，后台返回同样函数名的函数调用，<code>res.end(</code>getdata(\${JSON.stringify(obj)})<code>)</code>;</p><p>深拷贝浅拷贝的区别 深拷贝讨论的对象主要是指定<code>js</code>中的复杂数据类型 深拷贝不会对原对象产生影响 最简单的实现方式：<code>var cloneObj = JSON.parse(JSON.stringify(obj))</code>，这种方式的弊端不能实现对象中函数的拷贝 最符合需求的方式：<code>for in</code>循环加递归实现,<code>for in</code> 循环需要判断不同的数据类型，如果是对象使用递归克隆，如果是数组，可以直接调用<code>concat</code>方法或者<code>splice</code>方法进行深拷贝，如果是函数，使用<code>constructor</code>重新实例化函数和时间类型</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="shiki one-dark-pro" style="background-color:#282c34;" tabindex="0"><code><span class="line"><span style="color:#C678DD;">var</span><span style="color:#ABB2BF;"> </span><span style="color:#E06C75;">cloneObj</span><span style="color:#ABB2BF;"> </span><span style="color:#56B6C2;">=</span><span style="color:#ABB2BF;"> {}</span></span>
<span class="line"><span style="color:#E06C75;">fucntion</span><span style="color:#ABB2BF;"> </span><span style="color:#61AFEF;">deepClone</span><span style="color:#ABB2BF;">(</span><span style="color:#E06C75;">obj</span><span style="color:#ABB2BF;">){</span></span>
<span class="line"><span style="color:#ABB2BF;">  </span><span style="color:#C678DD;">var</span><span style="color:#ABB2BF;"> </span><span style="color:#E06C75;">cloneObj</span><span style="color:#ABB2BF;"> </span><span style="color:#56B6C2;">=</span><span style="color:#ABB2BF;"> {}</span></span>
<span class="line"><span style="color:#ABB2BF;"> </span><span style="color:#C678DD;">for</span><span style="color:#ABB2BF;"> (</span><span style="color:#C678DD;">var</span><span style="color:#ABB2BF;"> </span><span style="color:#E06C75;">key</span><span style="color:#ABB2BF;"> </span><span style="color:#C678DD;">in</span><span style="color:#ABB2BF;"> </span><span style="color:#E06C75;">obj</span><span style="color:#ABB2BF;">){</span></span>
<span class="line"><span style="color:#ABB2BF;">  </span><span style="color:#C678DD;">if</span><span style="color:#ABB2BF;">(</span><span style="color:#E5C07B;">obj</span><span style="color:#ABB2BF;">.</span><span style="color:#61AFEF;">hasOwnProperty</span><span style="color:#ABB2BF;">(</span><span style="color:#E06C75;">key</span><span style="color:#ABB2BF;">)){</span></span>
<span class="line"><span style="color:#ABB2BF;">   </span><span style="color:#C678DD;">if</span><span style="color:#ABB2BF;">(</span><span style="color:#C678DD;">typeof</span><span style="color:#ABB2BF;"> </span><span style="color:#E06C75;">obj</span><span style="color:#ABB2BF;">[</span><span style="color:#E06C75;">key</span><span style="color:#ABB2BF;">] </span><span style="color:#56B6C2;">===</span><span style="color:#ABB2BF;"> </span><span style="color:#98C379;">&#39;object&#39;</span><span style="color:#ABB2BF;">){</span></span>
<span class="line"><span style="color:#ABB2BF;">     </span><span style="color:#E06C75;">cloneObj</span><span style="color:#ABB2BF;"> </span><span style="color:#56B6C2;">=</span><span style="color:#ABB2BF;"> </span><span style="color:#61AFEF;">deepClone</span><span style="color:#ABB2BF;">(</span><span style="color:#E06C75;">obj</span><span style="color:#ABB2BF;">[</span><span style="color:#E06C75;">key</span><span style="color:#ABB2BF;">])</span></span>
<span class="line"><span style="color:#ABB2BF;">   }</span><span style="color:#C678DD;">else</span><span style="color:#ABB2BF;">{</span></span>
<span class="line"><span style="color:#ABB2BF;">    </span><span style="color:#E06C75;">cloneObj</span><span style="color:#ABB2BF;">[</span><span style="color:#E06C75;">key</span><span style="color:#ABB2BF;">] </span><span style="color:#56B6C2;">=</span><span style="color:#ABB2BF;"> </span><span style="color:#E06C75;">obj</span><span style="color:#ABB2BF;">[</span><span style="color:#E06C75;">key</span><span style="color:#ABB2BF;">]</span></span>
<span class="line"><span style="color:#ABB2BF;">   }</span></span>
<span class="line"><span style="color:#ABB2BF;">  }</span></span>
<span class="line"><span style="color:#ABB2BF;">  </span><span style="color:#C678DD;">return</span><span style="color:#ABB2BF;"> </span><span style="color:#E06C75;">cloneObj</span><span style="color:#ABB2BF;">;</span></span>
<span class="line"><span style="color:#ABB2BF;"> }</span></span>
<span class="line"><span style="color:#ABB2BF;">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="工作中处理过的兼容性问题" tabindex="-1"><a class="header-anchor" href="#工作中处理过的兼容性问题" aria-hidden="true">#</a> 工作中处理过的兼容性问题</h2><ul><li>移动端滚动穿透</li><li>移动端输入框被键盘挡住问题</li><li>IOS 滚动不平滑的问题</li><li>click 300ms 延迟响应</li></ul><h2 id="处理过的性能优化问题" tabindex="-1"><a class="header-anchor" href="#处理过的性能优化问题" aria-hidden="true">#</a> 处理过的性能优化问题</h2><h3 id="webpack里面" tabindex="-1"><a class="header-anchor" href="#webpack里面" aria-hidden="true">#</a> <code>webpack</code>里面</h3><ol><li>路由懒加载(组件按需加载)</li><li>分离第三方包(抽取第三方模块安装包的代码，减少<code>build.js</code>的体积)</li><li>分离<code>css</code>(减少<code>build.js</code>体积)</li></ol><h3 id="js" tabindex="-1"><a class="header-anchor" href="#js" aria-hidden="true">#</a> <code>JS</code></h3><ol><li>对高频触发的事件进行节流和防抖（<code>touchmove</code>）</li><li>尽量减少<code>HTTP</code>请求个数-需权衡（精灵图和合并请求，分离第三方包/<code>css</code>是拆分请求）</li><li>避免空的<code>src</code>和<code>href</code></li><li>减少<code>dom</code>访问，减少<code>DOM</code>访问层级（迫不得已需要访问<code>DOM</code>，可以将<code>DOM</code>进行缓存）</li><li>使用<code>CDN</code>（内容分发网络）（静态资源使用<code>CDN</code>加速，用户访问时从<code>CDN</code>获取资源，<code>CDN</code>根据 IP 地址直接返回当前城市服务器中的资源）</li></ol><h2 id="工作中遇到的难解决的问题-后来如何解决的" tabindex="-1"><a class="header-anchor" href="#工作中遇到的难解决的问题-后来如何解决的" aria-hidden="true">#</a> 工作中遇到的难解决的问题，后来如何解决的</h2><p><code>scoped</code>问题（父组件无法直接修改子组件的样式，<code>vue-loader</code>深度作用选择器）<br><code>mui</code>严格模式（当<code>webpack</code>项目中引入<code>mui.js</code>，会报<code>caller</code>,<code>callee</code>,<code>arguments</code>在严格模式下无法使用） 真正问题产生是由于<code>babel-loder</code>在编译代码时会加严格模式</p><ul><li>方法 1：<code>&quot;ignore&quot;:[&#39;./src/js/mui/mui.min.js&#39;]</code></li><li>方法 2：<code>{test:/\\.js$/,use:&#39;babel-loader&#39;,exclude:/mui\\.min\\.js/}</code></li><li>方法 3：安装 b<code>abel-plugin-transoform-remove-strict-mode</code>移除整个项目打包编译时的严格模式 <code>mui.css</code>引入到脚手架，打包时会报 SVG 图片属性错误（需要将<code>mui.css</code>文件中引入<code>SVG</code>图片的单引号改成双引号）</li></ul><h2 id="mvvm" tabindex="-1"><a class="header-anchor" href="#mvvm" aria-hidden="true">#</a> <code>MVVM</code></h2><p><code>MVVM</code>是<code>Model-View-ViewModel</code>缩写，也就是把<code>MVC</code>中的<code>Controller</code>演变成<code>ViewModel</code>。<code>Model</code>层代表数据模型，<code>View</code>代表<code>UI</code>组件，<code>ViewModel</code>是<code>View</code>和<code>Model</code>层的桥梁，数据会绑定到<code>viewModel</code>层并自动将数据渲染到页面中，视图变化的时候会通知<code>viewModel</code>层更新数据。</p><h2 id="nexttick知道吗-实现原理是什么" tabindex="-1"><a class="header-anchor" href="#nexttick知道吗-实现原理是什么" aria-hidden="true">#</a> <code>nextTick</code>知道吗,实现原理是什么</h2><p>在下次<code>DOM</code>更新循环结束之后执行延迟回调。<code>nextTick</code>主要使用了宏任务和微任务。根据执行环境分别尝试采用<code>Promise</code>、<code>MutationObserver</code>、<code>setImmediate</code>，如果以上都不行则采用<code>setTimeout</code><br> 定义了一个异步方法，多次调用<code>nextTick</code>会将方法存入队列中，通过这个异步方法清空当前队列</p><h2 id="组件中的data为什么是一个函数" tabindex="-1"><a class="header-anchor" href="#组件中的data为什么是一个函数" aria-hidden="true">#</a> 组件中的<code>data</code>为什么是一个函数</h2><p>一个组件被复用多次的话，也就会创建多个实例。本质上，这些实例用的都是同一个构造函数。如果<code>data</code>是对象的话，对象属于引用类型，会影响到所有的实例。所以为了保证组件不同的实例之间<code>data</code>不冲突，<code>data</code>必须是一个函数。</p><h2 id="v-model的原理" tabindex="-1"><a class="header-anchor" href="#v-model的原理" aria-hidden="true">#</a> <code>v-model</code>的原理</h2><p><code>v-model</code>本质就是一个语法糖，可以看成是<code>value</code> + <code>input</code>方法的语法糖。 可以通过<code>model</code>属性的<code>prop</code>和<code>event</code>属性来进行自定义。原生的<code>v-model</code>，会根据标签的不同生成不同的事件和属性。</p><h2 id="vue模版编译原理" tabindex="-1"><a class="header-anchor" href="#vue模版编译原理" aria-hidden="true">#</a> <code>Vue</code>模版编译原理</h2><p>简单说，<code>Vue</code>的编译过程就是将<code>template</code>转化为<code>render</code>函数的过程。会经历以下阶段：</p><ul><li>生成<code>AST</code>树</li><li>优化</li><li><code>codegen</code></li></ul><ol><li>首先解析模版，生成<code>AST</code>语法树(一种用<code>JavaScript</code>对象的形式来描述整个模板)。</li><li>使用大量的正则表达式对模板进行解析，遇到标签、文本的时候都会执行对应的钩子进行相关处理。</li><li>Vue 的数据是响应式的，但其实模板中并不是所有的数据都是响应式的。有一些数据首次渲染后就不会再变化，对应的 DOM 也不会变化。那么优化过程就是深度遍历 AST 树，按照相关条件对树节点进行标记。这些被标记的节点(静态节点)我们就可以跳过对它们的比对，对运行时的模板起到很大的优化作用。</li><li>编译的最后一步是将优化后的 AST 树转换为可执行的代码。</li></ol><h2 id="vue2-x和vue3-x渲染器的diff算法分别说一下" tabindex="-1"><a class="header-anchor" href="#vue2-x和vue3-x渲染器的diff算法分别说一下" aria-hidden="true">#</a> <code>Vue2.x</code>和<code>Vue3.x</code>渲染器的<code>diff</code>算法分别说一下</h2><p>简单来说，<code>diff</code>算法有以下过程</p><ul><li>同级比较，再比较子节点</li><li>先判断一方有子节点一方没有子节点的情况(如果新的<code>children</code>没有子节点，将旧的子节点移除)</li><li>比较都有子节点的情况(核心<code>diff</code>)</li><li>递归比较子节点</li><li>正常<code>Diff</code>两个树的时间复杂度是<code>O(n^3)</code>，但实际情况下我们很少会进行跨层级的移动<code>DOM</code>，所以<code>Vue</code>将<code>Diff</code>进行了优化，从<code>O(n^3)</code> -&gt; <code>O(n)</code>，只有当新旧<code>children</code>都为多个子节点时才需要用核心的<code>Diff</code>算法进行同层级比较。</li></ul><p><code>Vue2</code>的核心<code>Diff</code>算法采用了双端比较的算法，同时从新旧<code>children</code>的两端开始进行比较，借助<code>key</code>值找到可复用的节点，再进行相关操作。相比<code>React</code>的<code>Diff</code>算法，同样情况下可以减少移动节点次数，减少不必要的性能损耗，更加的优雅。</p><p><code>Vue3.x</code>借鉴了<code>ivi</code>算法和 <code>inferno</code>算法</p><p>在创建<code>VNode</code>时就确定其类型，以及在 <code>mount</code>/<code>patch</code> 的过程中采用位运算来判断一个<code>VNode</code>的类型，在这个基础之上再配合核心的<code>Diff</code>算法，使得性能上较<code>Vue2.x</code>有了提升。(实际的实现可以结合<code>Vue3.x</code>源码看。)</p><p>该算法中还运用了动态规划的思想求解最长递归子序列。</p><h2 id="再说一下虚拟-dom-以及-key-属性的作用" tabindex="-1"><a class="header-anchor" href="#再说一下虚拟-dom-以及-key-属性的作用" aria-hidden="true">#</a> 再说一下虚拟 Dom 以及 key 属性的作用</h2><p>由于在浏览器中操作<code>DOM</code>是很昂贵的。频繁的操作<code>DOM</code>，会产生一定的性能问题。这就是虚拟<code>Dom</code>的产生原因。</p><p><code>Vue2</code>的<code>Virtual DOM</code>借鉴了开源库<code>snabbdom</code>的实现。</p><p><code>Virtual DOM</code>本质就是用一个原生的<code>JS</code>对象去描述一个<code>DOM</code>节点。是对真实<code>DOM</code>的一层抽象。(也就是源码中的<code>VNode</code>类，它定义在<code>src/core/vdom/vnode.js</code>中。)</p><p><code>VirtualDOM</code>映射到真实<code>DOM</code>要经历<code>VNode</code>的<code>create</code>、<code>diff</code>、<code>patch</code>等阶段。</p><p><code>key</code>的作用是尽可能的复用 <code>DOM</code> 元素。</p><p>新旧 <code>children</code> 中的节点只有顺序是不同的时候，最佳的操作应该是通过移动元素的位置来达到更新的目的。</p><p>需要在新旧 <code>children</code> 的节点中保存映射关系，以便能够在旧 <code>children</code> 的节点中找到可复用的节点。<code>key</code>也就是<code>children</code>中节点的唯一标识。</p><h2 id="keep-alive-了解吗" tabindex="-1"><a class="header-anchor" href="#keep-alive-了解吗" aria-hidden="true">#</a> keep-alive 了解吗</h2><p><code>keep-alive</code>可以实现组件缓存，当组件切换时不会对当前组件进行卸载。<br> 常用的两个属性<code>include</code>/<code>exclude</code>，允许组件有条件的进行缓存。<br> 两个生命周期<code>activated</code>/<code>deactivated</code>，用来得知当前组件是否处于活跃状态。<br><code>keep-alive</code>的中还运用了<code>LRU(Least Recently Used)</code>算法。<br> 原理：<code>Vue.js</code>内部将<code>DOM</code>节点抽象成了一个个的<code>VNode</code>节点，<code>keep-alive</code>组件的缓存也是基于<code>VNode</code>节点的而不是直接存储<code>DOM</code>结构。它将满足条件（<code>pruneCache</code>与<code>pruneCache</code>）的组件在<code>cache</code>对象中缓存起来，在需要重新渲染的时候再将<code>vnode</code>节点从<code>cache</code>对象中取出并渲染。</p><h2 id="vue-中组件生命周期调用顺序说一下" tabindex="-1"><a class="header-anchor" href="#vue-中组件生命周期调用顺序说一下" aria-hidden="true">#</a> Vue 中组件生命周期调用顺序说一下</h2><p>组件的调用顺序都是先父后子,渲染完成的顺序是先子后父。</p><p>组件的销毁操作是先父后子，销毁完成的顺序是先子后父。</p><p>加载渲染过程<br> 父<code>beforeCreate</code>-&gt; 父<code>created</code>-&gt; 父<code>beforeMount</code>-&gt; 子<code>beforeCreate</code>-&gt; 子<code>created</code>-&gt; 子<code>beforeMount</code> -&gt; 子<code>mounted</code> -&gt; 父<code>mounted</code></p><p>子组件更新过程<br> 父<code>beforeUpdate</code> -&gt; 子<code>beforeUpdate</code> -&gt; 子<code>updated</code> -&gt; 父<code>updated</code></p><p>父组件更新过程<br> 父<code>beforeUpdate</code> -&gt; 父<code>updated</code></p><p>销毁过程<br> 父<code>beforeDestroy</code> -&gt; 子<code>beforeDestroy</code> -&gt; 子<code>destroyed</code> -&gt; 父<code>destroyed</code></p><h2 id="vue2-x-组件通信有哪些方式" tabindex="-1"><a class="header-anchor" href="#vue2-x-组件通信有哪些方式" aria-hidden="true">#</a> Vue2.x 组件通信有哪些方式</h2><h3 id="父子组件通信" tabindex="-1"><a class="header-anchor" href="#父子组件通信" aria-hidden="true">#</a> 父子组件通信</h3><ul><li><p>父 -&gt; 子<code>props</code>，子 -&gt; 父 <code>$on</code>、<code>$emit</code></p></li><li><p>获取父子组件实例 <code>$parent</code>、<code>$children</code></p></li><li><p><code>Ref</code> 获取实例的方式调用组件的属性或者方法</p></li><li><p><code>Provide</code>、<code>inject</code> 官方不推荐使用，但是写组件库时很常用</p></li></ul><h3 id="兄弟组件通信" tabindex="-1"><a class="header-anchor" href="#兄弟组件通信" aria-hidden="true">#</a> 兄弟组件通信</h3><ul><li><p><code>Event Bus</code> 实现跨组件通信 <code>Vue.prototype.$bus = new Vue</code></p></li><li><p><code>Vuex</code></p></li></ul><h3 id="跨级组件通信" tabindex="-1"><a class="header-anchor" href="#跨级组件通信" aria-hidden="true">#</a> 跨级组件通信</h3><ul><li><p><code>Vuex</code></p></li><li><p><code>$attrs</code>、<code>$listeners</code></p></li><li><p><code>Provide</code>、<code>inject</code></p></li></ul><h2 id="ssr了解吗" tabindex="-1"><a class="header-anchor" href="#ssr了解吗" aria-hidden="true">#</a> <code>SSR</code>了解吗</h2><p><code>SSR</code>也就是服务端渲染，也就是将<code>Vue</code>在客户端把标签渲染成<code>HTML</code>的工作放在服务端完成，然后再把<code>html</code>直接返回给客户端。</p><p><code>SSR</code>有着更好的<code>SEO</code>、并且首屏加载速度更快等优点。不过它也有一些缺点，比如我们的开发条件会受到限制，服务器端渲染只支持<code>beforeCreate</code>和<code>created</code>两个钩子，当我们需要一些外部扩展库时需要特殊处理，服务端渲染应用程序也需要处于<code>Node.js</code>的运行环境。还有就是服务器会有更大的负载需求。</p><h2 id="你都做过哪些vue的性能优化" tabindex="-1"><a class="header-anchor" href="#你都做过哪些vue的性能优化" aria-hidden="true">#</a> 你都做过哪些<code>Vue</code>的性能优化</h2><ol><li>编码阶段</li></ol><ul><li>尽量减少<code>data</code>中的数据，<code>data</code>中的数据都会增加<code>getter</code>和<code>setter</code>，会收集对应的<code>watcher</code></li><li><code>v-if</code>和<code>v-for</code>不能连用</li><li>如果需要使用<code>v-for</code>给每项元素绑定事件时使用事件代理</li><li><code>SPA</code> 页面采用<code>keep-alive</code>缓存组件</li><li>在更多的情况下，使用<code>v-if</code>替代<code>v-show</code></li><li><code>key</code>保证唯一</li><li>使用路由懒加载、异步组件</li><li>防抖、节流</li><li>第三方模块按需导入</li><li>长列表滚动到可视区域动态加载</li><li>图片懒加载</li></ul><ol start="2"><li><code>SEO</code>优化</li></ol><ul><li>预渲染</li><li>服务端渲染<code>SSR</code></li></ul><ol start="3"><li>打包优化</li></ol><ul><li>压缩代码</li><li><code>Tree Shaking</code>/<code>Scope Hoisting</code></li><li>使用<code>cdn</code>加载第三方模块</li><li>多线程打包<code>happypack</code></li><li><code>splitChunks</code>抽离公共文件</li><li><code>sourceMap</code>优化</li></ul><ol start="4"><li>用户体验</li></ol><ul><li>骨架屏</li><li><code>PWA</code></li><li>还可以使用缓存(客户端缓存、服务端缓存)优化、服务端开启<code>gzip</code>压缩等。</li></ul><h2 id="hash-路由和-history-路由实现原理说一下" tabindex="-1"><a class="header-anchor" href="#hash-路由和-history-路由实现原理说一下" aria-hidden="true">#</a> hash 路由和 history 路由实现原理说一下</h2><p><code>location.hash</code>的值实际就是<code>URL</code>中<code>#</code>后面的东西。 <code>history</code>实际采用了<code>HTML5中</code>提供的<code>API</code>来实现，主要有<code>history.pushState()</code>和<code>history.replaceState()</code>。</p><h2 id="v-for-中-key-的作用" tabindex="-1"><a class="header-anchor" href="#v-for-中-key-的作用" aria-hidden="true">#</a> v-for 中 key 的作用</h2><p><code>key</code>的作用主要是为了更高效的对比虚拟<code>DOM</code>中每个节点是否是相同节点; <code>Vue</code>在<code>patch</code>过程中判断两个节点是否是相同节点,<code>key</code>是一个必要条件，渲染一组列表时，<code>key</code>往往是唯一标识，所以如果不定义<code>key</code>的话，<code>Vue</code>只能认为比较的两个节点是同一个，哪怕它们实际上不是，这导致了频繁更新元素，使得整个<code>patch</code>过程比较低效，影响性能; 从源码中可以知道，<code>Vue</code>判断两个节点是否相同时主要判断两者的<code>key</code>和元素类型等，因此如果不设置<code>key</code>,它的值就是<code>undefined</code>，则可能永远认为这是两个相同的节点，只能去做更新操作，这造成了大量的<code>dom</code>更新操作，明显是不可取的。</p>`,116),l=[n];function d(p,i){return o(),s("div",null,l)}const B=e(c,[["render",d],["__file","vue.html.vue"]]);export{B as default};
