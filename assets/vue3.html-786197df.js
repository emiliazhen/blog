import{_ as e}from"./plugin-vue_export-helper-c27b6911.js";import{o,c,a as d}from"./app-fd217ae5.js";const t={},r=d('<h2 id="vue3-0-里为什么要用-proxy-api-替代-defineproperty-api" tabindex="-1"><a class="header-anchor" href="#vue3-0-里为什么要用-proxy-api-替代-defineproperty-api" aria-hidden="true">#</a> <code>Vue3.0</code> 里为什么要用 <code>Proxy API</code> 替代 <code>defineProperty API</code></h2><ol><li><code>defineProperty API</code> 的局限性最大原因是它只能针对单例属性做监听 <code>Vue2.x</code>中的响应式实现正是基于<code>defineProperty</code>中的<code>descriptor</code>，对 <code>data</code> 中的属性做了遍历 + 递归，为每个属性设置了 <code>getter</code>、<code>setter</code>。这也就是为什么 <code>Vue</code> 只能对 <code>data</code> 中预定义过的属性做出响应的原因，在<code>Vue</code>中使用下标的方式直接修改属性的值或者添加一个预先不存在的对象属性是无法做到<code>setter</code>监听的，这是<code>defineProperty</code>的局限性</li><li><code>Proxy API</code>的监听是针对一个对象的，那么对这个对象的所有操作会进入监听操作， 这就完全可以代理所有属性，将会带来很大的性能提升和更优的代码</li><li>响应式是惰性的 在 <code>Vue.js 2.x</code> 中，对于一个深层属性嵌套的对象，要劫持它内部深层次的变化，就需要递归遍历这个对象，执行 <code>Object.defineProperty</code> 把每一层对象数据都变成响应式的，这无疑会有很大的性能消耗。<br> 在 <code>Vue.js 3.0</code> 中，使用 <code>Proxy API</code> 并不能监听到对象内部深层次的属性变化，因此它的处理方式是在 <code>getter</code> 中去递归响应式，这样的好处是真正访问到的内部属性才会变成响应式，简单的可以说是按需实现响应式，减少性能消耗。</li></ol><h2 id="vue3编译做了哪些优化" tabindex="-1"><a class="header-anchor" href="#vue3编译做了哪些优化" aria-hidden="true">#</a> <code>vue3</code>编译做了哪些优化</h2><ol><li>生成 <code>Block tree</code><code>Vue.js 2.x</code> 的数据更新并触发重新渲染的粒度是组件级的，单个组件内部 需要遍历该组件的整个 <code>vnode</code> 树。<br> 在<code>2.0</code>里，渲染效率的快慢与组件大小成正相关：组件越大，渲染效率越慢。并且，对于一些静态节点，又无数据更新，这些遍历都是性能浪费。 <code>Vue.js 3.0</code> 做到了通过编译阶段对静态模板的分析，编译生成了 <code>Block tree</code>。 <code>Block tree</code>是一个将模版基于动态节点指令切割的嵌套区块，每个 区块内部的节点结构是固定的，每个区块只需要追踪自身包含的动态节点。 所以，在<code>3.0</code>里，渲染效率不再与模板大小成正相关，而是与模板中动态节点的数量成正相关。</li><li><code>slot</code> 编译优化 <code>Vue.js 2.x</code> 中，如果有一个组件传入了<code>slot</code>，那么每次父组件更新的时候，会强制使子组件<code>update</code>，造成性能的浪费。 <code>Vue.js 3.0</code> 优化了<code>slot</code>的生成，使得非动态<code>slot</code>中属性的更新只会触发子组件的更新。 动态<code>slot</code>指的是在<code>slot</code>上面使用<code>v-if</code>，<code>v-for</code>，动态<code>slot</code>名字等会导致<code>slot</code>产生运行时动态变化但是又无法被子组件<code>track</code>的操作。</li><li><code>diff</code>算法优化</li></ol><h2 id="vue3-0新特性-——-composition-api-与-react-js-中-hooks的异同点" tabindex="-1"><a class="header-anchor" href="#vue3-0新特性-——-composition-api-与-react-js-中-hooks的异同点" aria-hidden="true">#</a> <code>Vue3.0</code>新特性 —— <code>Composition API</code> 与 <code>React.js</code> 中 <code>Hooks</code>的异同点</h2><ol><li><code>React.js</code> 中的 <code>Hooks</code> 基本使用 <code>React Hooks</code> 允许你 &quot;勾入&quot; 诸如组件状态和副作用处理等 <code>React</code> 功能中。<code>Hooks</code> 只能用在函数组件中，并允许我们在不需要创建类的情况下将状态、副作用处理和更多东西带入组件中。<br><code>React</code> 核心团队奉上的采纳策略是不反对类组件，所以你可以升级 <code>React</code> 版本、在新组件中开始尝试 <code>Hooks</code>，并保持既有组件不做任何更改。</li><li><code>Vue Composition API</code> 基本使用 <code>Vue Composition API</code> 围绕一个新的组件选项 <code>setup</code> 而创建。<code>setup()</code> 为 <code>Vue</code> 组件提供了状态、计算值、<code>watcher</code> 和生命周期钩子。<br> 并没有让原来的 <code>API（Options-based API）</code>消失。允许开发者 结合使用新旧两种 <code>API</code>（向下兼容）</li><li>原理 <code>React hook</code> 底层是基于链表实现，调用的条件是每次组件被<code>render</code>的时候都会顺序执行所有的<code>hooks</code>。<br><code>vue hook</code> 只会被注册调用一次，<code>vue</code> 能避开这些麻烦的问题，原因在于它对数据的响应是基于<code>proxy</code>的，对数据直接代理观察。<br> （这种场景下，只要任何一个更改<code>data</code>的地方，相关的<code>function</code>或者<code>template</code>都会被重新计算，因此避开了<code>react</code>可能遇到的性能上的问题）。<br><code>react</code> 中，数据更改的时候，会导致重新<code>render</code>，重新<code>render</code>又会重新把<code>hooks</code>重新注册一次，所以<code>react</code>复杂程度会高一些。</li></ol><h2 id="vue3-0是如何变得更快的" tabindex="-1"><a class="header-anchor" href="#vue3-0是如何变得更快的" aria-hidden="true">#</a> <code>Vue3.0</code>是如何变得更快的</h2><ol><li><code>diff</code>方法优化 <code>Vue2.x</code> 中的虚拟 dom 是进行全量的对比。<br><code>Vue3.0</code> 中新增了静态标记（<code>PatchFlag</code>）：在与上次虚拟结点进行对比的时候，值对比带有 <code>patch flag</code> 的节点，并且可以通过 <code>flag</code> 的信息得知当前节点要对比的具体内容化。</li><li><code>hoistStatic</code> 静态提升 <code>Vue2.x</code> : 无论元素是否参与更新，每次都会重新创建。<br><code>Vue3.0</code> : 对不参与更新的元素，只会被创建一次，之后会在每次渲染时候被不停的复用。</li><li><code>cacheHandlers</code> 事件侦听器缓存 默认情况下<code>onClick</code>会被视为动态绑定，所以每次都会去追踪它的变化但是因为是同一个函数，所以没有追踪变化，直接缓存起来复用即可。</li></ol>',8),a=[r];function i(s,l){return o(),c("div",null,a)}const h=e(t,[["render",i],["__file","vue3.html.vue"]]);export{h as default};
