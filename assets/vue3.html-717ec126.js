const e=JSON.parse('{"key":"v-795ba52d","path":"/consolidate/vue3.html","title":"巩固Vue3","lang":"zh-CN","frontmatter":{"title":"巩固Vue3","date":"2021-09-03T00:00:00.000Z","order":7,"icon":"vue"},"headers":[{"level":2,"title":"Vue3.0 里为什么要用 Proxy API 替代 defineProperty API","slug":"vue3-0-里为什么要用-proxy-api-替代-defineproperty-api","link":"#vue3-0-里为什么要用-proxy-api-替代-defineproperty-api","children":[]},{"level":2,"title":"vue3编译做了哪些优化","slug":"vue3编译做了哪些优化","link":"#vue3编译做了哪些优化","children":[]},{"level":2,"title":"Vue3.0新特性 —— Composition API 与 React.js 中 Hooks的异同点","slug":"vue3-0新特性-——-composition-api-与-react-js-中-hooks的异同点","link":"#vue3-0新特性-——-composition-api-与-react-js-中-hooks的异同点","children":[]},{"level":2,"title":"Vue3.0是如何变得更快的","slug":"vue3-0是如何变得更快的","link":"#vue3-0是如何变得更快的","children":[]}],"git":{},"readingTime":{"minutes":4.52,"words":1357},"filePathRelative":"consolidate/vue3.md","localizedDate":"2021年9月3日","excerpt":"<h2> <code>Vue3.0</code> 里为什么要用 <code>Proxy API</code> 替代 <code>defineProperty API</code></h2>\\n<ol>\\n<li><code>defineProperty API</code> 的局限性最大原因是它只能针对单例属性做监听\\n<code>Vue2.x</code>中的响应式实现正是基于<code>defineProperty</code>中的<code>descriptor</code>，对 <code>data</code> 中的属性做了遍历 + 递归，为每个属性设置了 <code>getter</code>、<code>setter</code>。这也就是为什么 <code>Vue</code> 只能对 <code>data</code> 中预定义过的属性做出响应的原因，在<code>Vue</code>中使用下标的方式直接修改属性的值或者添加一个预先不存在的对象属性是无法做到<code>setter</code>监听的，这是<code>defineProperty</code>的局限性</li>\\n<li><code>Proxy API</code>的监听是针对一个对象的，那么对这个对象的所有操作会进入监听操作， 这就完全可以代理所有属性，将会带来很大的性能提升和更优的代码</li>\\n<li>响应式是惰性的\\n在 <code>Vue.js 2.x</code> 中，对于一个深层属性嵌套的对象，要劫持它内部深层次的变化，就需要递归遍历这个对象，执行 <code>Object.defineProperty</code> 把每一层对象数据都变成响应式的，这无疑会有很大的性能消耗。<br>\\n在 <code>Vue.js 3.0</code> 中，使用 <code>Proxy API</code> 并不能监听到对象内部深层次的属性变化，因此它的处理方式是在 <code>getter</code> 中去递归响应式，这样的好处是真正访问到的内部属性才会变成响应式，简单的可以说是按需实现响应式，减少性能消耗。</li>\\n</ol>"}');export{e as data};
