import{_ as e}from"./plugin-vue_export-helper-c27b6911.js";import{o as d,c as o,a as c}from"./app-fd217ae5.js";const t={},a=c('<h2 id="flutter与reactnative区别" tabindex="-1"><a class="header-anchor" href="#flutter与reactnative区别" aria-hidden="true">#</a> <code>Flutter</code>与<code>ReactNative</code>区别</h2><p><code>Flutter</code>通过<code>dart</code>语言开发，<code>ReactNative</code>使用<code>JS</code>开发<br><code>Flutter</code>对<code>android</code>支持更好,<code>ReactNative</code>对苹果支持更好<br> 两者最终都能生成原生<code>APP</code></p><h2 id="widgets、renderobjects-和-elements的关系" tabindex="-1"><a class="header-anchor" href="#widgets、renderobjects-和-elements的关系" aria-hidden="true">#</a> <code>Widgets</code>、<code>RenderObjects</code> 和 <code>Elements</code>的关系</h2><p><code>widgets</code>是由<code>elements</code>管理的，包括<code>widget</code>的状态，位置信息等，<code>RenderObjects</code>是用来渲染绘制的，最终页面能够呈现在我们的手机屏幕上就是靠<code>RenderObjects</code>。</p><h2 id="flutter使用到的-key-有哪些" tabindex="-1"><a class="header-anchor" href="#flutter使用到的-key-有哪些" aria-hidden="true">#</a> <code>flutter</code>使用到的 Key 有哪些</h2><p><code>localkey</code>、<code>globalkey</code>、<code>uniquekey</code>、<code>ObjectKey</code>，<code>globalkey</code>可以是全局的<code>key</code>，整个应用唯一的，是很昂贵的，允许<code>element</code>在树周围移动或变更父节点而不会丢失状态，一般尽量少用。</p><h2 id="stateless-widget和stateful-widget区别" tabindex="-1"><a class="header-anchor" href="#stateless-widget和stateful-widget区别" aria-hidden="true">#</a> <code>Stateless Widget</code>和<code>Stateful Widget</code>区别</h2><p><code>Stateless</code>是无状态，不会重新绘制页面，<code>Stateful</code> 使用状态的，可以通过<code>setstate</code>来让页面重新绘制，所以一般如果不需要保持状态的页面应该使用<code>stateless Widget</code>，这样可以减少页面的加载时间及内存的占用。</p><h2 id="flutter页面的生命周期" tabindex="-1"><a class="header-anchor" href="#flutter页面的生命周期" aria-hidden="true">#</a> <code>flutter</code>页面的生命周期</h2><p>类似原生<code>android</code>或者<code>ios</code>开发一样，<code>flutter</code>也有自己的声明周期，如下：</p><ul><li><code>initState()</code></li><li><code>didChangeDependencies()</code></li><li><code>build()</code></li><li><code>reassemble()</code></li><li><code>didUpdateWidget()</code></li><li><code>deactivate()</code></li><li><code>dispose()</code></li></ul><h2 id="有使用过哪些常用的第三方框架" tabindex="-1"><a class="header-anchor" href="#有使用过哪些常用的第三方框架" aria-hidden="true">#</a> 有使用过哪些常用的第三方框架？</h2><p><code>provider</code>状态管理插件，<code>fluro</code>路由管理插件，<code>sqflite</code>数据库插件等</p><h2 id="hot-restart-和-hot-reload-有什么区别吗" tabindex="-1"><a class="header-anchor" href="#hot-restart-和-hot-reload-有什么区别吗" aria-hidden="true">#</a> <code>Hot Restart</code> 和 <code>Hot Reload</code> 有什么区别吗？</h2><p><code>Hot Restart</code>重启整个应用，也就是重新编译代码， <code>Hot Reload</code>只是加载部分更改的代码，所以<code>hot reload</code>是比<code>hot restart</code>更快的显示。</p><h2 id="future-和stream的区别" tabindex="-1"><a class="header-anchor" href="#future-和stream的区别" aria-hidden="true">#</a> <code>future</code> 和<code>stream</code>的区别</h2><p>都是用来异步处理的，<code>future</code>是单个异步的，而<code>stream</code>是操作连续的异步处理</p><h2 id="mixin特性" tabindex="-1"><a class="header-anchor" href="#mixin特性" aria-hidden="true">#</a> <code>mixin</code>特性</h2><p><code>mixin</code>是<code>dart</code>语言独有的新特性，意思就是可以混入多个类，类似多继承，但并不是传统的那种继承，<code>mixin</code>定义的类不能有构造方法，避免了与父类的构造方法的冲突</p><h2 id="flutter架构介绍" tabindex="-1"><a class="header-anchor" href="#flutter架构介绍" aria-hidden="true">#</a> <code>Flutter</code>架构介绍</h2><p><code>flutter</code>主要有三层<code>Framework</code>、<code>Engine</code>、<code>Embedder</code></p><ul><li><code>framework</code>就是提供给我们开发的各种组件等，</li><li><code>engine</code>就是把我们的代码编译运行，帮我们渲染<code>UI</code>，绘制图形等</li><li><code>Embedder</code>是用来映射成原生的<code>app</code></li></ul>',22),r=[a];function i(l,s){return d(),o("div",null,r)}const u=e(t,[["render",i],["__file","flutter.html.vue"]]);export{u as default};
