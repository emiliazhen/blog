import{_ as e}from"./plugin-vue_export-helper-c27b6911.js";import{o as l,c as a,a as s}from"./app-fd217ae5.js";const i={},o=s(`<h2 id="rem-原理" tabindex="-1"><a class="header-anchor" href="#rem-原理" aria-hidden="true">#</a> rem 原理</h2><ul><li><code>rem</code>布局的本质是等比缩放，一般是基于宽度，假设将屏幕宽度分为<code>100</code>份，每份宽度是<code>1rem</code>，<code>1rem</code>的宽度是<code>屏幕宽度/100</code>,，然后子元素设置<code>rem</code>单位的属性， 通过改变<code>html</code>元素的字体大小，就可以设置子元素的实际大小。</li><li><code>rem</code>布局加载闪烁的问题 解决方案，媒体查询设置根元素字体大小，比如设计稿是<code>750px</code>;对应的开发方式是<code>1rem=100px</code>,那<code>375px</code>的<code>font-size</code> 大小就是<code>50px</code>（具体方法可以百度一下）</li><li>比<code>rem</code>更好的方案（缺点兼容不好） <code>vw</code>(<code>1vw</code>是视口宽度的<code>1%</code>，<code>100vw</code>就是视口宽度),<code>vh</code>(<code>100vh</code>就是视口高度)</li></ul><h2 id="实现三栏布局" tabindex="-1"><a class="header-anchor" href="#实现三栏布局" aria-hidden="true">#</a> 实现三栏布局</h2><p>两侧定宽，中间自适应</p><ol><li>采用了 absolute，导致父元素脱离了文档流，那所有的子元素也需要脱离文档流。如果页面复杂，那开发的难度可想而知</li><li>利用浮动 当中间内容高于两侧时，两侧高度不会随中间内容变高而变高</li><li>弹性盒子布局</li><li>利用负边距和浮动,实现起来比较复杂</li><li>利用网格布局</li></ol><div class="language-css line-numbers-mode" data-ext="css"><pre class="shiki one-dark-pro" style="background-color:#282c34;" tabindex="0"><code><span class="line"><span style="color:#D19A66;">.container</span><span style="color:#ABB2BF;"> {</span></span>
<span class="line"><span style="color:#ABB2BF;">  display: </span><span style="color:#D19A66;">grid</span><span style="color:#ABB2BF;">;</span></span>
<span class="line"><span style="color:#ABB2BF;">  grid-template-columns: </span><span style="color:#D19A66;">100</span><span style="color:#E06C75;">px</span><span style="color:#ABB2BF;"> </span><span style="color:#D19A66;">auto</span><span style="color:#ABB2BF;"> </span><span style="color:#D19A66;">200</span><span style="color:#E06C75;">px</span><span style="color:#ABB2BF;">;</span></span>
<span class="line"><span style="color:#ABB2BF;">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="bfc-块级格式化上下文" tabindex="-1"><a class="header-anchor" href="#bfc-块级格式化上下文" aria-hidden="true">#</a> BFC（块级格式化上下文）</h2><h3 id="bfc-的原理-其实也就是-bfc-的渲染规则-能说出以下四点就够了-。包括" tabindex="-1"><a class="header-anchor" href="#bfc-的原理-其实也就是-bfc-的渲染规则-能说出以下四点就够了-。包括" aria-hidden="true">#</a> BFC 的原理 其实也就是 BFC 的渲染规则（能说出以下四点就够了）。包括：</h3><ol><li>BFC 内部的子元素，在垂直方向，边距会发生重叠。</li><li>BFC 在页面中是独立的容器，外面的元素不会影响里面的元素，反之亦然。</li><li>BFC 区域不与旁边的 float box 区域重叠。（可以用来清除浮动带来的影响）。</li><li>计算 BFC 的高度时，浮动的子元素也参与计算。</li></ol><h3 id="如何生成-bfc" tabindex="-1"><a class="header-anchor" href="#如何生成-bfc" aria-hidden="true">#</a> 如何生成 BFC</h3><ul><li>方法 1：overflow: 不为 visible，可以让属性是 hidden、auto。【最常用】</li><li>方法 2：浮动中：float 的属性值不为 none。意思是，只要设置了浮动，当前元素就创建了 BFC。</li><li>方法 3：定位中：只要 posiiton 的值不是 static 或者是 relative 即可，可以是 absolute 或 fixed，也就生成了一个 BFC。</li><li>方法 4：display 为 inline-block, table-cell, table-caption, flex, inline-flex</li></ul><h3 id="bfc-应用" tabindex="-1"><a class="header-anchor" href="#bfc-应用" aria-hidden="true">#</a> BFC 应用</h3><ul><li>阻止 margin 重叠</li><li>可以包含浮动元素 —— 清除内部浮动(清除浮动的原理是两个 div 都位于同一个 BFC 区域之中)</li><li>自适应两栏布局</li><li>可以阻止元素被浮动元素覆盖</li></ul><h2 id="flex" tabindex="-1"><a class="header-anchor" href="#flex" aria-hidden="true">#</a> flex</h2><p>面试常问，略</p>`,15),c=[o];function n(d,r){return l(),a("div",null,c)}const h=e(i,[["render",n],["__file","css.html.vue"]]);export{h as default};
