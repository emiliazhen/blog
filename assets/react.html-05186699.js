import{_ as e}from"./plugin-vue_export-helper-c27b6911.js";import{o as d,c,a as o}from"./app-fd217ae5.js";const a={},t=o('<h2 id="react中key的作用-有key没key有什么区别-比较同一层级节点什么意思" tabindex="-1"><a class="header-anchor" href="#react中key的作用-有key没key有什么区别-比较同一层级节点什么意思" aria-hidden="true">#</a> <code>react</code>中<code>key</code>的作用，有<code>key</code>没<code>key</code>有什么区别，比较同一层级节点什么意思？</h2><p><code>Keys</code>是<code>React</code>用于追踪哪些列表中元素被修改、被添加或者被移除的辅助标识</p><h2 id="你对虚拟dom和diff算法的理解-实现render函数" tabindex="-1"><a class="header-anchor" href="#你对虚拟dom和diff算法的理解-实现render函数" aria-hidden="true">#</a> 你对虚拟<code>dom</code>和<code>diff</code>算法的理解，实现<code>render</code>函数</h2><p>虚拟<code>DOM</code>本质上是<code>JavaScript</code>对象,是对真实<code>DOM</code>的抽象表现。<br> 状态变更时，记录新树和旧树的差异<br> 最后把差异更新到真正的<code>dom</code>中<br><code>render</code>函数:<br> 根据<code>tagName</code>生成父标签,读取<code>props</code>，设置属性，如果有<code>content</code>，设置<code>innerHtml</code>或<code>innerText</code>,<br> 如果存在子元素，遍历子元素递归调用<code>render</code>方法，将生成的子元素依次添加到父元素中，并返回根元素。</p><h2 id="react组件之间通信方式" tabindex="-1"><a class="header-anchor" href="#react组件之间通信方式" aria-hidden="true">#</a> <code>React</code>组件之间通信方式</h2><ol><li>父子组件,父 -&gt; 子直接用<code>Props</code>,子 -&gt; 父用<code>callback</code>回调</li><li>非父子组件,用发布订阅模式的<code>Event</code>模块</li><li>项目复杂的话用<code>Redux</code>、<code>Mobx</code>等全局状态管理管库</li><li><code>Context Api context</code> 会使组件复用性变差 <code>Context</code> 提供了一个无需为每层组件手动添加 <code>props</code>，就能在组件树间进行数据传递的方法.如果你只是想避免层层传递一些属性，组件组合（<code>component composition</code>）有时候是一个比 <code>context</code> 更好的解决方案。</li><li>组件组合缺点：会使高层组件变得复杂</li></ol><h2 id="生命周期都有哪几种-分别是在什么阶段做哪些事情-为什么要废弃一些生命周期" tabindex="-1"><a class="header-anchor" href="#生命周期都有哪几种-分别是在什么阶段做哪些事情-为什么要废弃一些生命周期" aria-hidden="true">#</a> 生命周期都有哪几种，分别是在什么阶段做哪些事情？为什么要废弃一些生命周期？</h2><p><code>componentWillMount</code>、<code>componentWillReceiveProps</code>、<code>componentWillUpdate</code>在 16 版本被废弃，在 17 版本将被删除，需要使用<code>UNSAVE_</code>前缀使用，目的是向下兼容。</p><h2 id="react的优化方法" tabindex="-1"><a class="header-anchor" href="#react的优化方法" aria-hidden="true">#</a> <code>react</code>的优化方法</h2><ol><li>代码层面： 使用<code>return null</code>而不是<code>CSS</code>的<code>display:none</code>来控制节点的显示隐藏。保证同一时间页面的<code>DOM</code>节点尽可能的少。</li><li><code>props</code>和<code>state</code>的数据尽可能简单明了，扁平化。 不要使用数组下标作为<code>key</code><br> 利用 <code>shouldComponentUpdate</code> 和 <code>PureComponent</code> 避免过多 <code>render function</code>;<br><code>render</code>里面尽量减少新建变量和<code>bind</code>函数，传递参数是尽量减少传递参数的数量。<br> 尽量将 <code>props</code> 和 <code>state</code> 扁平化，只传递 <code>component</code> 需要的 <code>props</code>（传得太多，或者层次传得太深，都会加重<code>shouldComponentUpdate</code>里面的数据比较负担），慎将 <code>component</code> 当作 <code>props</code> 传入</li><li>代码体积： 使用 <code>babel-plugin-import</code> 优化业务组件的引入，实现按需加载<br> 使用 <code>SplitChunksPlugin</code> 拆分公共代码<br> 使用动态 <code>import</code>，懒加载 <code>React</code> 组件</li></ol><h2 id="setstate是同步还是异步的" tabindex="-1"><a class="header-anchor" href="#setstate是同步还是异步的" aria-hidden="true">#</a> <code>setState</code>是同步还是异步的</h2><ol><li><code>setState</code>只在合成事件和钩子函数中是“异步”的，在原生事件和 <code>setTimeout</code> 中都是同步的。</li><li><code>setState</code>的“异步”并不是说内部由异步代码实现，其实本身执行的过程和代码都是同步的，只是合成事件和钩子函数的调用顺序在更新之前，导致在合成事件和钩子函数中没法立马拿到更新后的值，形式了所谓的“异步”，当然可以通过第二个参数 <code>setState(partialState, callback)</code> 中的<code>callback</code>拿到更新后的结果。</li><li><code>setState</code> 的批量更新优化也是建立在“异步”（合成事件、钩子函数）之上的，在原生事件和<code>setTimeout</code> 中不会批量更新，在“异步”中如果对同一个值进行多次 <code>setState</code> ， <code>setState</code> 的批量更新策略会对其进行覆盖，取最后一次的执行，如果是同时 <code>setState</code> 多个不同的值，在更新时会对其进行合并批量更新。</li></ol><h2 id="redux、react-redux" tabindex="-1"><a class="header-anchor" href="#redux、react-redux" aria-hidden="true">#</a> <code>Redux</code>、<code>React-Redux</code></h2><h3 id="redux的实现流程" tabindex="-1"><a class="header-anchor" href="#redux的实现流程" aria-hidden="true">#</a> <code>Redux</code>的实现流程</h3><p>用户页面行为触发一个<code>Action</code>，然后<code>Store</code>调用<code>Reducer</code>，并且传入两个参数：当前<code>State</code>和收到的<code>Action</code>。<code>Reducer</code>会返回新的<code>State</code>。每当<code>state</code>更新之后，<code>view</code>会根据<code>state</code>触发重新渲染。</p><h3 id="react-redux" tabindex="-1"><a class="header-anchor" href="#react-redux" aria-hidden="true">#</a> <code>React-Redux</code></h3><ul><li><code>Provider</code>：从最外部封装了整个应用，并向<code>connect</code>模块传递<code>store</code>。</li><li><code>Connect</code>： <ul><li>包装原组件，将<code>state</code>和<code>action</code>通过<code>props</code>的方式传入到原组件内部。</li><li>监听<code>store tree</code>变化，使其包装的原组件可以响应<code>state</code>变化</li></ul></li></ul><h2 id="对高阶组件的理解" tabindex="-1"><a class="header-anchor" href="#对高阶组件的理解" aria-hidden="true">#</a> 对高阶组件的理解</h2><p>高阶组件是参数为组件，返回值为新组件的函数。<code>HOC</code>是纯函数，没有副作用。<code>HOC</code>在<code>React</code>的第三方库中很常见，例如<code>Redux</code>的<code>connect</code>组件。</p><h3 id="高阶组件的作用" tabindex="-1"><a class="header-anchor" href="#高阶组件的作用" aria-hidden="true">#</a> 高阶组件的作用：</h3><ul><li>代码复用，逻辑抽象，抽离底层准备（<code>bootstrap</code>）代码</li><li>渲染劫持</li><li><code>State</code> 抽象和更改</li><li><code>Props</code> 更改</li></ul><h2 id="可以用哪些方式创建react组件" tabindex="-1"><a class="header-anchor" href="#可以用哪些方式创建react组件" aria-hidden="true">#</a> 可以用哪些方式创建<code>React</code>组件？</h2><ul><li><code>React.createClass()</code></li><li><code>ES6 class</code></li><li>无状态函数</li></ul><h2 id="react元素与组件的区别" tabindex="-1"><a class="header-anchor" href="#react元素与组件的区别" aria-hidden="true">#</a> <code>React</code>元素与组件的区别？</h2><p>组件是由元素构成的。元素数据结构是普通对象，而组件数据结构是类或纯函数。</p><h2 id="vue与react对比" tabindex="-1"><a class="header-anchor" href="#vue与react对比" aria-hidden="true">#</a> <code>Vue</code>与<code>React</code>对比？</h2><h3 id="数据流" tabindex="-1"><a class="header-anchor" href="#数据流" aria-hidden="true">#</a> 数据流：</h3><ul><li><code>react</code>主张函数式编程，所以推崇纯组件，数据不可变，单向数据流，</li><li><code>vue</code>的思想是响应式的，也就是基于是数据可变的，通过对每一个属性建立<code>Watcher</code>来监听，当属性变化的时候，响应式的更新对应的虚拟<code>dom</code>。</li></ul><h3 id="监听数据变化实现原理" tabindex="-1"><a class="header-anchor" href="#监听数据变化实现原理" aria-hidden="true">#</a> 监听数据变化实现原理：</h3><ul><li><code>Vue</code> 通过 <code>getter</code>/<code>setter</code> 以及一些函数的劫持，能精确知道数据变化，不需要特别的优化就能达到很好的性能</li><li><code>React</code> 默认是通过比较引用的方式进行的，如果不优化(<code>PureComponent</code>/<code>shouldComponentUpdate</code>)可能导致大量不必要的<code>VDOM</code>的重新渲染。</li></ul><h3 id="组件通信的区别-jsx-和-vue-模板。" tabindex="-1"><a class="header-anchor" href="#组件通信的区别-jsx-和-vue-模板。" aria-hidden="true">#</a> 组件通信的区别：jsx 和.vue 模板。</h3><p><code>HoC</code>和<code>Mixins</code>(在 Vue 中我们组合不同功能的方式是通过<code>Mixin</code>，而在<code>React</code>中我们通过<code>HoC</code>(高阶组件))。</p><h3 id="性能优化" tabindex="-1"><a class="header-anchor" href="#性能优化" aria-hidden="true">#</a> 性能优化</h3><ul><li><code>React</code>: <code>shouldComponentUpdate</code></li><li><code>Vue</code>:内部实现<code>shouldComponentUpdate</code>的优化，由于依赖追踪系统存在，通过<code>watcher</code>判断是否需要重新渲染(当一个页面数据量较大时，<code>Vue</code>的性能较差，造成页面卡顿，所以一般数据比较大的项目倾向使用 React)。</li></ul><h2 id="vuex-和-redux-之间的区别" tabindex="-1"><a class="header-anchor" href="#vuex-和-redux-之间的区别" aria-hidden="true">#</a> vuex 和 redux 之间的区别？</h2><p>从实现原理上来说，最大的区别是两点：</p><ul><li><code>Redux</code>使用的是不可变数据，而<code>Vuex</code>的数据是可变的。<code>Redux</code>每次都是用新的<code>state</code>替换旧的<code>state</code>，而<code>Vuex</code>是直接修改</li><li><code>Redux</code>在检测数据变化的时候，是通过<code>diff</code>的方式比较差异的，而<code>Vuex</code>其实和<code>Vue</code>的原理一样，是通过 <code>getter</code>/<code>setter</code>来比较的(如果看<code>Vuex</code>源码会知道，其实他内部直接创建一个<code>Vue</code>实例用来跟踪数据变化)</li></ul>',37),r=[t];function i(l,n){return d(),c("div",null,r)}const u=e(a,[["render",i],["__file","react.html.vue"]]);export{u as default};
