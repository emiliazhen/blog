import{_ as s}from"./plugin-vue_export-helper-c27b6911.js";import{o as a,c as e,a as o}from"./app-fd217ae5.js";const n={},l=o(`<h2 id="typeof返回哪些数据类型" tabindex="-1"><a class="header-anchor" href="#typeof返回哪些数据类型" aria-hidden="true">#</a> <code>typeof</code>返回哪些数据类型</h2><ul><li>object</li><li>string</li><li>boolean</li><li>number</li><li>undefined</li><li>function</li></ul><h2 id="split-join-区别" tabindex="-1"><a class="header-anchor" href="#split-join-区别" aria-hidden="true">#</a> <code>split()</code> <code>join()</code>区别</h2><p><code>split()</code>切割成数组形式，<code>join()</code>将数组转换成字符串</p><h2 id="数组方法-pop-push-unshift-shift" tabindex="-1"><a class="header-anchor" href="#数组方法-pop-push-unshift-shift" aria-hidden="true">#</a> 数组方法 pop() push() unshift() shift()</h2><ul><li>push()尾部添加</li><li>pop()尾部删除</li><li>unshift()头部添加</li><li>shift()头部删除</li></ul><h2 id="事件绑定和普通事件的区别" tabindex="-1"><a class="header-anchor" href="#事件绑定和普通事件的区别" aria-hidden="true">#</a> 事件绑定和普通事件的区别</h2><p>普通添加事件</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="shiki one-dark-pro" style="background-color:#282c34;" tabindex="0"><code><span class="line"><span style="color:#E5C07B;">btn</span><span style="color:#ABB2BF;">.</span><span style="color:#61AFEF;">onclick</span><span style="color:#ABB2BF;"> </span><span style="color:#56B6C2;">=</span><span style="color:#ABB2BF;"> </span><span style="color:#C678DD;">function</span><span style="color:#ABB2BF;"> () {</span></span>
<span class="line"><span style="color:#ABB2BF;">  </span><span style="color:#61AFEF;">alert</span><span style="color:#ABB2BF;">(</span><span style="color:#D19A66;">1</span><span style="color:#ABB2BF;">)</span></span>
<span class="line"><span style="color:#ABB2BF;">}</span></span>
<span class="line"><span style="color:#E5C07B;">btn</span><span style="color:#ABB2BF;">.</span><span style="color:#61AFEF;">onclick</span><span style="color:#ABB2BF;"> </span><span style="color:#56B6C2;">=</span><span style="color:#ABB2BF;"> </span><span style="color:#C678DD;">function</span><span style="color:#ABB2BF;"> () {</span></span>
<span class="line"><span style="color:#ABB2BF;">  </span><span style="color:#61AFEF;">alert</span><span style="color:#ABB2BF;">(</span><span style="color:#D19A66;">2</span><span style="color:#ABB2BF;">)</span></span>
<span class="line"><span style="color:#ABB2BF;">}</span></span>
<span class="line"><span style="color:#7F848E;font-style:italic;">// 执行代码只会 alert(2)</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>事件绑定方式添加事件</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="shiki one-dark-pro" style="background-color:#282c34;" tabindex="0"><code><span class="line"><span style="color:#E5C07B;">btn</span><span style="color:#ABB2BF;">.</span><span style="color:#61AFEF;">addEventListener</span><span style="color:#ABB2BF;">(</span><span style="color:#98C379;">&#39;click&#39;</span><span style="color:#ABB2BF;">, </span><span style="color:#C678DD;">function</span><span style="color:#ABB2BF;"> () {</span></span>
<span class="line"><span style="color:#ABB2BF;">  </span><span style="color:#61AFEF;">alert</span><span style="color:#ABB2BF;">(</span><span style="color:#D19A66;">1</span><span style="color:#ABB2BF;">)</span></span>
<span class="line"><span style="color:#ABB2BF;">})</span></span>
<span class="line"><span style="color:#E5C07B;">btn</span><span style="color:#ABB2BF;">.</span><span style="color:#61AFEF;">addEventListener</span><span style="color:#ABB2BF;">(</span><span style="color:#98C379;">&#39;click&#39;</span><span style="color:#ABB2BF;">, </span><span style="color:#C678DD;">function</span><span style="color:#ABB2BF;"> () {</span></span>
<span class="line"><span style="color:#ABB2BF;">  </span><span style="color:#61AFEF;">alert</span><span style="color:#ABB2BF;">(</span><span style="color:#D19A66;">2</span><span style="color:#ABB2BF;">)</span></span>
<span class="line"><span style="color:#ABB2BF;">})</span></span>
<span class="line"><span style="color:#7F848E;font-style:italic;">// 执行代码会先 alert(1) 再 alert(2)</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>普通添加时间的方法不支持添加多个事件，最下面的事件会覆盖上面的，而事件绑定方式添加事件可以添加多个</li><li>addEventListener 不兼容低版本 IE</li><li>普通事件无法取消</li><li>addEventListener 支持事件冒泡+事件捕获</li></ul><h2 id="ie和dom事件流的区别" tabindex="-1"><a class="header-anchor" href="#ie和dom事件流的区别" aria-hidden="true">#</a> <code>IE</code>和<code>DOM</code>事件流的区别</h2><ul><li>事件流区别：<code>IE</code>采用冒泡型时间 <code>Netscape</code>使用捕获型事件 <code>DOM</code>使用先捕获后冒泡型时间</li><li>事件监听函数区别：<code>IE</code>使用<code>attachEvent(&#39;name&#39;,function);</code> <code>detachEvent(..)</code>，<code>DOM</code>使用<code>addEventListener(&#39;name&#39;,function,bCapture);</code> <code>removerEventListener</code></li></ul><h2 id="call和apply的区别" tabindex="-1"><a class="header-anchor" href="#call和apply的区别" aria-hidden="true">#</a> <code>call</code>和<code>apply</code>的区别</h2><p>-<code>call(thisObj,object1,object2..)</code>，调用一个对象的一个方法，以另一个对象替换当前对象。 -<code>apply(thisObj,[..])</code>用某一对象的一个方法，用另一个对象替换当前对象。 -<code>foo.call(this,arg1,arg2,arg3)==foo.apply(this.arguments)==this.foo(arg1,arg2,arg3)</code></p><h2 id="阻止事件冒泡和默认时间" tabindex="-1"><a class="header-anchor" href="#阻止事件冒泡和默认时间" aria-hidden="true">#</a> 阻止事件冒泡和默认时间</h2><ul><li><code>cancelBubble()</code>只支持 IE，</li><li><code>return false</code>,<code>stopPropagation()</code></li></ul><h2 id="添加删除替换插入到某个节点的方法" tabindex="-1"><a class="header-anchor" href="#添加删除替换插入到某个节点的方法" aria-hidden="true">#</a> 添加删除替换插入到某个节点的方法</h2><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="shiki one-dark-pro" style="background-color:#282c34;" tabindex="0"><code><span class="line"><span style="color:#E5C07B;">obj</span><span style="color:#ABB2BF;">.</span><span style="color:#61AFEF;">appendChild</span><span style="color:#ABB2BF;">()</span></span>
<span class="line"><span style="color:#E5C07B;">obj</span><span style="color:#ABB2BF;">.</span><span style="color:#61AFEF;">insertBefore</span><span style="color:#ABB2BF;">()</span></span>
<span class="line"><span style="color:#E5C07B;">obj</span><span style="color:#ABB2BF;">.</span><span style="color:#61AFEF;">replaceChild</span><span style="color:#ABB2BF;">()</span></span>
<span class="line"><span style="color:#E5C07B;">obj</span><span style="color:#ABB2BF;">.</span><span style="color:#61AFEF;">removeChild</span><span style="color:#ABB2BF;">()</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="javascript的本地对象-内置对象和宿主对象" tabindex="-1"><a class="header-anchor" href="#javascript的本地对象-内置对象和宿主对象" aria-hidden="true">#</a> <code>javascript</code>的本地对象，内置对象和宿主对象</h2><ul><li>本地对象为<code>array</code>,<code>obj</code>,<code>regexp</code>等可以 new 实例化</li><li>内置对象为<code>gload</code>，<code>Math</code>等不可以实例化</li><li>宿主为浏览器自带的<code>document</code>,<code>window</code>等</li></ul><h2 id="window-onload和document-ready的区别" tabindex="-1"><a class="header-anchor" href="#window-onload和document-ready的区别" aria-hidden="true">#</a> <code>window.onload</code>和<code>document ready</code>的区别</h2><p><code>window.onload</code>是在<code>dom</code>文档树加载完和所有文件加载完之后执行一个函数，<code>document.ready</code>原生中没有这个方法，<code>jQuery</code>中有<code>$().ready(function)</code>，在<code>dom</code>文档树加载完之后执行一个函数，这里的文档树加载不代表全部文件加载完。<code>$(document).ready</code>要比<code>window.onload</code>先执行，<code>window.onload</code>只能出来一次，<code>$(document).ready</code>可以出现多次</p><h2 id="和-的不同" tabindex="-1"><a class="header-anchor" href="#和-的不同" aria-hidden="true">#</a> <code>==</code>和<code>===</code>的不同</h2><p><code>==</code>会自动转换类型</p><h2 id="javascript的同源策略" tabindex="-1"><a class="header-anchor" href="#javascript的同源策略" aria-hidden="true">#</a> <code>javascript</code>的同源策略</h2><p>一段脚本只能读取来自同一来源的窗口和文档的属性，这里的同一来源指的是主机名、协议和端口号</p><h2 id="javascipt的特点" tabindex="-1"><a class="header-anchor" href="#javascipt的特点" aria-hidden="true">#</a> <code>Javascipt</code>的特点</h2><p>是一种直译式脚本语言(代码不进行预编译)，是一种动态类型、弱类型、基于原型的语言，内置支持类型</p><h2 id="javascript的数据类型都有什么" tabindex="-1"><a class="header-anchor" href="#javascript的数据类型都有什么" aria-hidden="true">#</a> <code>Javascript</code>的数据类型都有什么</h2><ul><li>基本数据类型：<code>String</code>,<code>Boolean</code>,<code>Number</code>,<code>Undefined</code>,<code>Null</code></li><li>引用数据类型：<code>Object(Array,Date,RegExp,Function)</code></li></ul><h2 id="如何判断某变量是否为数组数据类型" tabindex="-1"><a class="header-anchor" href="#如何判断某变量是否为数组数据类型" aria-hidden="true">#</a> 如何判断某变量是否为数组数据类型</h2><p><code>obj instanceof Array</code>,在某些<code>IE</code>版本中不正确<br><code>ES5</code>中定义了新方法<code>Array.isArray()</code></p><h2 id="当一个dom节点被点击时希望能执行一个函数怎么做" tabindex="-1"><a class="header-anchor" href="#当一个dom节点被点击时希望能执行一个函数怎么做" aria-hidden="true">#</a> 当一个<code>DOM</code>节点被点击时希望能执行一个函数怎么做</h2><ul><li>在<code>DOM</code>里绑定事件：<code>&lt;div onclick = &quot;test()&quot;&gt;&lt;/div&gt;</code></li><li>在<code>js</code>里通过<code>onclick</code>绑定：<code>xxx.onclick = test</code></li><li>通过事件添加进行绑定：<code>addEventListener(xxx.&#39;click&#39;,test)</code></li></ul><h2 id="javascript-如何实现继承" tabindex="-1"><a class="header-anchor" href="#javascript-如何实现继承" aria-hidden="true">#</a> Javascript 如何实现继承</h2><ol><li>构造函数绑定 使用 call 或 apply 方法，将父对象的构造函数绑定在子对象上</li></ol><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="shiki one-dark-pro" style="background-color:#282c34;" tabindex="0"><code><span class="line"><span style="color:#C678DD;">function</span><span style="color:#ABB2BF;"> </span><span style="color:#61AFEF;">Cat</span><span style="color:#ABB2BF;">(</span><span style="color:#E06C75;font-style:italic;">name</span><span style="color:#ABB2BF;">, </span><span style="color:#E06C75;font-style:italic;">color</span><span style="color:#ABB2BF;">) {</span></span>
<span class="line"><span style="color:#ABB2BF;">  </span><span style="color:#E5C07B;">Animal</span><span style="color:#ABB2BF;">.</span><span style="color:#61AFEF;">apply</span><span style="color:#ABB2BF;">(</span><span style="color:#E5C07B;">this</span><span style="color:#ABB2BF;">.</span><span style="color:#E06C75;">arguments</span><span style="color:#ABB2BF;">)</span></span>
<span class="line"><span style="color:#ABB2BF;">  </span><span style="color:#E5C07B;">this</span><span style="color:#ABB2BF;">.</span><span style="color:#E06C75;">name</span><span style="color:#ABB2BF;"> </span><span style="color:#56B6C2;">=</span><span style="color:#ABB2BF;"> </span><span style="color:#E06C75;">name</span></span>
<span class="line"><span style="color:#ABB2BF;">  </span><span style="color:#E5C07B;">this</span><span style="color:#ABB2BF;">.</span><span style="color:#E06C75;">color</span><span style="color:#ABB2BF;"> </span><span style="color:#56B6C2;">=</span><span style="color:#ABB2BF;"> </span><span style="color:#E06C75;">color</span></span>
<span class="line"><span style="color:#ABB2BF;">}</span></span>
<span class="line"><span style="color:#C678DD;">var</span><span style="color:#ABB2BF;"> </span><span style="color:#E06C75;">cat1</span><span style="color:#ABB2BF;"> </span><span style="color:#56B6C2;">=</span><span style="color:#ABB2BF;"> </span><span style="color:#C678DD;">new</span><span style="color:#ABB2BF;"> </span><span style="color:#61AFEF;">Cat</span><span style="color:#ABB2BF;">(</span><span style="color:#98C379;">&#39;catA&#39;</span><span style="color:#ABB2BF;">, </span><span style="color:#98C379;">&#39;yellow&#39;</span><span style="color:#ABB2BF;">)</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ol start="2"><li><code>prototype</code>模式</li></ol><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="shiki one-dark-pro" style="background-color:#282c34;" tabindex="0"><code><span class="line"><span style="color:#E5C07B;">Cat</span><span style="color:#ABB2BF;">.</span><span style="color:#E06C75;">prototype</span><span style="color:#ABB2BF;"> </span><span style="color:#56B6C2;">=</span><span style="color:#ABB2BF;"> </span><span style="color:#C678DD;">new</span><span style="color:#ABB2BF;"> </span><span style="color:#61AFEF;">Animal</span><span style="color:#ABB2BF;">()</span></span>
<span class="line"><span style="color:#E5C07B;">Cat</span><span style="color:#ABB2BF;">.</span><span style="color:#E06C75;">prototype</span><span style="color:#ABB2BF;">.</span><span style="color:#E06C75;">constructor</span><span style="color:#ABB2BF;"> </span><span style="color:#56B6C2;">=</span><span style="color:#ABB2BF;"> </span><span style="color:#E06C75;">Cat</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><ol start="3"><li>直接继承<code>prototype</code></li></ol><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="shiki one-dark-pro" style="background-color:#282c34;" tabindex="0"><code><span class="line"><span style="color:#E5C07B;">Animal</span><span style="color:#ABB2BF;">.</span><span style="color:#E06C75;">prototype</span><span style="color:#ABB2BF;">.</span><span style="color:#E06C75;">species</span><span style="color:#ABB2BF;"> </span><span style="color:#56B6C2;">=</span><span style="color:#ABB2BF;"> </span><span style="color:#98C379;">&#39;动物&#39;</span></span>
<span class="line"><span style="color:#E5C07B;">Cat</span><span style="color:#ABB2BF;">.</span><span style="color:#E06C75;">prototype</span><span style="color:#ABB2BF;"> </span><span style="color:#56B6C2;">=</span><span style="color:#ABB2BF;"> </span><span style="color:#E5C07B;">Animal</span><span style="color:#ABB2BF;">.</span><span style="color:#E06C75;">prototype</span></span>
<span class="line"><span style="color:#E5C07B;">Cat</span><span style="color:#ABB2BF;">.</span><span style="color:#E06C75;">prototype</span><span style="color:#ABB2BF;">.</span><span style="color:#E06C75;">constructor</span><span style="color:#ABB2BF;"> </span><span style="color:#56B6C2;">=</span><span style="color:#ABB2BF;"> </span><span style="color:#E06C75;">Cat</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ol start="4"><li>利用空对象做中介</li></ol><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="shiki one-dark-pro" style="background-color:#282c34;" tabindex="0"><code><span class="line"><span style="color:#C678DD;">var</span><span style="color:#ABB2BF;"> </span><span style="color:#61AFEF;">F</span><span style="color:#ABB2BF;"> </span><span style="color:#56B6C2;">=</span><span style="color:#ABB2BF;"> </span><span style="color:#C678DD;">function</span><span style="color:#ABB2BF;"> () {}</span></span>
<span class="line"><span style="color:#E5C07B;">F</span><span style="color:#ABB2BF;">.</span><span style="color:#E06C75;">prototype</span><span style="color:#ABB2BF;"> </span><span style="color:#56B6C2;">=</span><span style="color:#ABB2BF;"> </span><span style="color:#E5C07B;">Animal</span><span style="color:#ABB2BF;">.</span><span style="color:#E06C75;">prototype</span></span>
<span class="line"><span style="color:#E5C07B;">Cat</span><span style="color:#ABB2BF;">.</span><span style="color:#E06C75;">prototype</span><span style="color:#ABB2BF;"> </span><span style="color:#56B6C2;">=</span><span style="color:#ABB2BF;"> </span><span style="color:#C678DD;">new</span><span style="color:#ABB2BF;"> </span><span style="color:#61AFEF;">F</span><span style="color:#ABB2BF;">()</span></span>
<span class="line"><span style="color:#E5C07B;">Cat</span><span style="color:#ABB2BF;">.</span><span style="color:#E06C75;">prototype</span><span style="color:#ABB2BF;">.</span><span style="color:#E06C75;">constructor</span><span style="color:#ABB2BF;"> </span><span style="color:#56B6C2;">=</span><span style="color:#ABB2BF;"> </span><span style="color:#E06C75;">Cat</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ol start="5"><li>拷贝继承</li></ol><h2 id="iframe的优缺点" tabindex="-1"><a class="header-anchor" href="#iframe的优缺点" aria-hidden="true">#</a> <code>iframe</code>的优缺点</h2><p>优点：</p><ol><li>解决加载缓慢的第三方内容如图标和广告等的加载问题</li><li><code>Securtiy</code> <code>sandbox</code></li><li>并行加载脚本</li></ol><p>缺点:</p><ol><li><code>iframe</code>会阻塞主页的<code>onload</code>事件</li><li>即使内容为空，加载也需要时间</li><li>没有语义</li></ol><h2 id="js延时加载的方式" tabindex="-1"><a class="header-anchor" href="#js延时加载的方式" aria-hidden="true">#</a> <code>js</code>延时加载的方式</h2><ol><li><code>defer</code>和<code>async</code></li><li>动态创建<code>DOM</code>方式（创建<code>script</code>，插入到<code>DOM</code>中，加载完毕后<code>callBack</code>）</li><li>按需异步载入<code>js</code></li></ol><h2 id="哪些操作会造成内存泄漏" tabindex="-1"><a class="header-anchor" href="#哪些操作会造成内存泄漏" aria-hidden="true">#</a> 哪些操作会造成内存泄漏</h2><p>内存泄漏指任何对象在您不再拥有或需要它之后仍然存在<br> 垃圾回收器定期扫描对象，并计算引用了每个对象的其他对象的数量。如果一个对象的引用数量为<code>0</code>，或对该对象的唯一引用是循环的，那么该对象的内存即可回收</p><ol><li><code>setTimeout</code>的第一个参数使用字符串而非函数会引发内存泄漏</li><li>闭包</li><li>控制台日志</li><li>循环</li></ol><h2 id="闭包是什么-有什么特性-对页面有什么影响" tabindex="-1"><a class="header-anchor" href="#闭包是什么-有什么特性-对页面有什么影响" aria-hidden="true">#</a> 闭包是什么，有什么特性，对页面有什么影响</h2><p>闭包就是能够读取其他函数内部变量的函数<br> 闭包用途：</p><ul><li>能够访问函数定义时所在的词法作用域(阻止其被回收)</li><li>私有化变量</li><li>模拟块级作用域</li><li>创建模块</li></ul><p>闭包缺点：会导致函数的变量一直保存在内存中，过多的闭包可能会导致内存泄漏</p><h2 id="bind-live-delegate-区别" tabindex="-1"><a class="header-anchor" href="#bind-live-delegate-区别" aria-hidden="true">#</a> <code>bind()</code>,<code>live()</code>,<code>delegate()</code>区别</h2><ul><li><code>bind</code>:绑定事件，对新添加的事件不起作用，方法用于将一个处理程序附加到每个匹配元素的事件上并返回 jQuery 对象</li><li><code>live</code>:方法将一个事件处理程序附加到与当前选择器匹配的所有元素（包含现有的或将来添加的）的指定事件上并返回 jQuery 对象</li><li><code>delegate</code>:方法基于一组特定的根元素将处理程序附加到匹配选择器的所有元素（现有的或将来的）的一个或多个事件上</li></ul><h2 id="优化自己的代码" tabindex="-1"><a class="header-anchor" href="#优化自己的代码" aria-hidden="true">#</a> 优化自己的代码</h2><p>代码重用，避免全局变量，拆分函数避免函数过于臃肿，注释</p><h2 id="在javascript中什么是伪数组-如何将伪数组转化成标准数组" tabindex="-1"><a class="header-anchor" href="#在javascript中什么是伪数组-如何将伪数组转化成标准数组" aria-hidden="true">#</a> 在<code>javascript</code>中什么是伪数组，如何将伪数组转化成标准数组</h2><p>伪数组：无法直接调用数组方法或期望<code>length</code>属性有什么特殊的行为，但仍可以对真正数组遍历方法来遍历他们。典型的是函数<code>argument</code>参数，还有像调用<code>getElementsByTagName</code>,<code>document.childNodes</code>之类的，他们都返回<code>NodeList</code>对象都属于伪数组。</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="shiki one-dark-pro" style="background-color:#282c34;" tabindex="0"><code><span class="line"><span style="color:#E5C07B;">Array</span><span style="color:#ABB2BF;">.</span><span style="color:#E06C75;">prototype</span><span style="color:#ABB2BF;">.</span><span style="color:#E5C07B;">slice</span><span style="color:#ABB2BF;">.</span><span style="color:#61AFEF;">call</span><span style="color:#ABB2BF;">(</span><span style="color:#E06C75;">fakeArray</span><span style="color:#ABB2BF;">)</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h2 id="js-中有一个函数执行对象查找时永远不会查找原型" tabindex="-1"><a class="header-anchor" href="#js-中有一个函数执行对象查找时永远不会查找原型" aria-hidden="true">#</a> Js 中有一个函数执行对象查找时永远不会查找原型</h2><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="shiki one-dark-pro" style="background-color:#282c34;" tabindex="0"><code><span class="line"><span style="color:#E06C75;">HasOwnProperty</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h2 id="模块化开发" tabindex="-1"><a class="header-anchor" href="#模块化开发" aria-hidden="true">#</a> 模块化开发</h2><p>理解模块化开发模式：浏览器端<code>requirejs</code>,<code>seajs</code>；服务器端<code>nodejs</code>；<code>ES6</code>模块化；<code>fis</code>、<code>webpack</code>等前端整体模块化解决方案；<code>grunt</code>、<code>gulp</code>等前端工作流的使用</p><h2 id="amd-modules-asynchronous-definition-、cmd-common-module-definition-区别" tabindex="-1"><a class="header-anchor" href="#amd-modules-asynchronous-definition-、cmd-common-module-definition-区别" aria-hidden="true">#</a> <code>AMD(Modules/Asynchronous-Definition)</code>、<code>CMD(Common Module Definition)</code>区别</h2><p>理解这两种规范的差异主要通过<code>requirejs</code>与<code>seajs</code>的对比，理解模块的定义与引用方式的差异以及这两种规范的设计原则</p><h2 id="requirejs的核心原理是什么" tabindex="-1"><a class="header-anchor" href="#requirejs的核心原理是什么" aria-hidden="true">#</a> <code>requireJS</code>的核心原理是什么</h2><p>核心是<code>js</code>的加载模块，通过正则匹配模块以及模块的依赖关系，保证文件加载的先后顺序，根据文件的路径对加载过的文件做了缓存</p><h2 id="js继承的6种方法" tabindex="-1"><a class="header-anchor" href="#js继承的6种方法" aria-hidden="true">#</a> <code>js</code>继承的<code>6</code>种方法</h2><ol><li>原型链继承</li><li>借用构造函数继承</li><li>组合继承（原型+借用构造）</li><li>原型式继承</li><li>寄生式继承</li><li>寄生组合式继承</li></ol><h2 id="sass-less区别" tabindex="-1"><a class="header-anchor" href="#sass-less区别" aria-hidden="true">#</a> <code>Sass</code> <code>Less</code>区别</h2><ul><li>他们是动态的样式语言，是<code>CSS</code>预处理器，<code>CSS</code>上的一种抽象层</li><li>变量符不一样，<code>less</code>是<code>@</code>,<code>Sass</code>是<code>$</code></li><li><code>Sass</code>支持条件语句，可以使用<code>if{}else{}</code>,<code>for{}</code>循环等，而<code>less</code>不支持</li><li><code>Sass</code>是基于<code>Ruby</code>的，是在服务端处理的，而<code>less</code>是需要引入<code>less.js</code>来处理<code>less</code>代码输出<code>css</code>到浏览器</li></ul><h2 id="this-的理解" tabindex="-1"><a class="header-anchor" href="#this-的理解" aria-hidden="true">#</a> <code>this</code> 的理解</h2><ul><li>在 <code>js</code> 中，<code>this</code> 通常指向我们正在执行的函数本身或者是指向该函数所属对象</li><li>全局 <code>this</code> 指向 <code>window</code></li><li>函数中的 <code>this</code> 指向的是函数所在的对象</li><li>对象中的 <code>this</code> 指向其本身</li></ul>`,81),c=[l];function d(p,i){return a(),e("div",null,c)}const B=s(n,[["render",d],["__file","js.html.vue"]]);export{B as default};
